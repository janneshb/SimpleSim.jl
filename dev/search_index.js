var documenterSearchIndex = {"docs":
[{"location":"integrators/rkf45/#Runge-Kutta-Fehlberg-Method-/-RKF45","page":"Runge-Kutta-Fehlberg","title":"Runge-Kutta-Fehlberg Method / RKF45","text":"","category":"section"},{"location":"integrators/rkf45/#Usage","page":"Runge-Kutta-Fehlberg","title":"Usage","text":"","category":"section"},{"location":"integrators/rkf45/","page":"Runge-Kutta-Fehlberg","title":"Runge-Kutta-Fehlberg","text":"The desired integration method used for continuous-time dynamics is passed to the simulate function as a keyword argument.","category":"page"},{"location":"integrators/rkf45/","page":"Runge-Kutta-Fehlberg","title":"Runge-Kutta-Fehlberg","text":"using SimpleSim\n\n# my_model = ...\n\nout = simulate(my_model, T = T_end, integrator = RKF45)","category":"page"},{"location":"integrators/rkf45/#Mathematical-Background","page":"Runge-Kutta-Fehlberg","title":"Mathematical Background","text":"","category":"section"},{"location":"functions/random_vars/#Using-Random-Variables-in-your-Simulation","page":"Random Variables","title":"Using Random Variables in your Simulation","text":"","category":"section"},{"location":"integrators/overview/#Continuous-Time-Intgration-Methods-–-An-Overview","page":"Overview","title":"Continuous-Time Intgration Methods – An Overview","text":"","category":"section"},{"location":"integrators/overview/#Available-Solving-Methods","page":"Overview","title":"Available Solving Methods","text":"","category":"section"},{"location":"integrators/overview/","page":"Overview","title":"Overview","text":"Forward Euler Euler\nHeun's Method Heun\nForth-Order Runge-Kutta Method RK4\nRunge-Kutta-Fehlberg-Method RKF45","category":"page"},{"location":"integrators/overview/","page":"Overview","title":"Overview","text":"The list is ordered by fastest to slowest and at the same time by least to most precise.","category":"page"},{"location":"integrators/overview/#Usage","page":"Overview","title":"Usage","text":"","category":"section"},{"location":"integrators/overview/","page":"Overview","title":"Overview","text":"Supported integration methods are listed in the enum SimpleSimIntegrator exported by SimpleSim.jl.","category":"page"},{"location":"integrators/overview/","page":"Overview","title":"Overview","text":"@enum SimpleSimIntegrator RK4 = 1 Euler = 2 Heun = 3 RKF45 = 4","category":"page"},{"location":"integrators/overview/","page":"Overview","title":"Overview","text":"To choose an integration method for simulation, use the integrator keyword argument.","category":"page"},{"location":"integrators/overview/","page":"Overview","title":"Overview","text":"out = simulate(my_model, T = T_end, integrator = Heun)","category":"page"},{"location":"integrators/overview/","page":"Overview","title":"Overview","text":"Fourth-order Runge-Kutta (RK4) is used by default.","category":"page"},{"location":"integrators/overview/#Step-Size-Computation","page":"Overview","title":"Step Size Computation","text":"","category":"section"},{"location":"integrators/overview/","page":"Overview","title":"Overview","text":"The step size Delta t stays constant over the whole duration of the simulation. It is computed as the minimum of Δt_max, a keyword argument of simulate, and the greatest common divisor of Δt_max and all Δt values given for all models in the simulation.","category":"page"},{"location":"integrators/overview/","page":"Overview","title":"Overview","text":"All continuous-time models that are part of the same simulation are updated at the same frequency determined by the \"fastest\" model in the simulation. Neglecting performance concerns it is always better to update continuous-time models more frequently.","category":"page"},{"location":"integrators/overview/","page":"Overview","title":"Overview","text":"Example:","category":"page"},{"location":"integrators/overview/","page":"Overview","title":"Overview","text":"Assume you have set up a model that should be updated at least every twelfth of a second.","category":"page"},{"location":"integrators/overview/","page":"Overview","title":"Overview","text":"my_model = (\n    # ...\n    Δt = 1 // 12,\n)\n\nout = simulate(my_model, T = T_end, Δt_max = 1 // 20)","category":"page"},{"location":"integrators/overview/","page":"Overview","title":"Overview","text":"The fixed step size integrators will now be called with Δt = 1 // 60, which is the greatest common divisor of frac112 and frac120.","category":"page"},{"location":"integrators/overview/","page":"Overview","title":"Overview","text":"By default, Δt_maxis set to 1 // 100 which is more than sufficient for most applications.","category":"page"},{"location":"integrators/euler/#Forward-Euler-Integration-/-Euler","page":"Euler","title":"Forward Euler Integration / Euler","text":"","category":"section"},{"location":"integrators/euler/#Usage","page":"Euler","title":"Usage","text":"","category":"section"},{"location":"integrators/euler/","page":"Euler","title":"Euler","text":"The desired integration method used for continuous-time dynamics is passed to the simulate function as a keyword argument.","category":"page"},{"location":"integrators/euler/","page":"Euler","title":"Euler","text":"using SimpleSim\n\n# my_model = ...\n\nout = simulate(my_model, T = T_end, integrator = Euler)","category":"page"},{"location":"integrators/euler/#Mathematical-Background","page":"Euler","title":"Mathematical Background","text":"","category":"section"},{"location":"integrators/euler/","page":"Euler","title":"Euler","text":"The state x^+ estimating the true state at time t+Delta t is determined by simple integration of the current derivative dotx(t) computed using the dynamics function f(x(t) u(t) p t).","category":"page"},{"location":"integrators/euler/","page":"Euler","title":"Euler","text":"x^+ = x + Delta t cdot f(x u(t) p t)","category":"page"},{"location":"integrators/euler/","page":"Euler","title":"Euler","text":"This method is also referred to as forward Euler method and is the most basic explicit method for solving initial value problems.","category":"page"},{"location":"integrators/euler/","page":"Euler","title":"Euler","text":"You can read more about this topic on Wikipedia or any text book on the topic, many of which are available on the internet.","category":"page"},{"location":"integrators/euler/#Performance","page":"Euler","title":"Performance","text":"","category":"section"},{"location":"integrators/euler/","page":"Euler","title":"Euler","text":"For each iteration, the dynamics function f is only called once and the state update itself is computationally very inexpensive.","category":"page"},{"location":"misc/#Miscellanoues-Functionalities","page":"Miscellaneous","title":"Miscellanoues Functionalities","text":"","category":"section"},{"location":"misc/#Analyzing-the-Model-Structure","page":"Miscellaneous","title":"Analyzing the Model Structure","text":"","category":"section"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"print_model_tree(model; io = stdout)","category":"page"},{"location":"misc/#SimpleSim.print_model_tree-Tuple{Any}","page":"Miscellaneous","title":"SimpleSim.print_model_tree","text":"print_model_tree(model; io = stdout)\n\nPrints a tree of the given model similar to a folder tree printed by the Linux tree command.\n\nAn example for a feedback-controlled inverted pendulum could look like this\n\njulia> print_model_tree(my_model)\n└─1 (TypeCT): top-level model / FeedbackSystem\n  ├─2 (TypeCT): .inverted_pendulum / NamedTuple\n  └─3 (TypeCT): .controller / NamedTuple\n\nFirst, the model_id is indicated, following the type (TypeCT, TypeDT or TypeHybrid). Then follows the name of each model in the super model. This is either its field name in the NamedTuple passed as models or the index in the case of vectors or tuples. Finally, after the slash, the type of each model is indicated. This should either be the name of a struct type, or NamedTuple.\n\nYou can also pass your own IO stream to print_model_tree as follows\n\nprint_model_tree(my_buffer, model)\n\n\n\n\n\n","category":"method"},{"location":"integrators/heun/#Heun's-Method-/-Explicit-Trapezoidal-Integration-/-Heun","page":"Heun","title":"Heun's Method / Explicit Trapezoidal Integration / Heun","text":"","category":"section"},{"location":"integrators/heun/#Usage","page":"Heun","title":"Usage","text":"","category":"section"},{"location":"integrators/heun/","page":"Heun","title":"Heun","text":"The desired integration method used for continuous-time dynamics is passed to the simulate function as a keyword argument.","category":"page"},{"location":"integrators/heun/","page":"Heun","title":"Heun","text":"using SimpleSim\n\n# my_model = ...\n\nout = simulate(my_model, T = T_end, integrator = Heun)","category":"page"},{"location":"integrators/heun/#Mathematical-Background","page":"Heun","title":"Mathematical Background","text":"","category":"section"},{"location":"integrators/heun/","page":"Heun","title":"Heun","text":"Heun's method, also known as improved Euler's method or explicit trapezoidal rule is a two-stage method.","category":"page"},{"location":"integrators/heun/","page":"Heun","title":"Heun","text":"First, an intermediate estimate of the next state tildex^+ is computed using Euler's method","category":"page"},{"location":"integrators/heun/","page":"Heun","title":"Heun","text":"tildex^+ = x + Delta tcdot f(x u(t) p t)","category":"page"},{"location":"integrators/heun/","page":"Heun","title":"Heun","text":"The final estimate x^+ is then computed using a weighted average of the current derivative and the expected derivative at the next Euler step.","category":"page"},{"location":"integrators/heun/","page":"Heun","title":"Heun","text":"x^+ = x + fracDelta t2 (f(x u(t) p t) + f(tildex^+ u(t + Delta t) p t + Delta t))","category":"page"},{"location":"integrators/heun/","page":"Heun","title":"Heun","text":"You can read more about this topic on Wikipedia.","category":"page"},{"location":"integrators/heun/#Performance","page":"Heun","title":"Performance","text":"","category":"section"},{"location":"integrators/heun/","page":"Heun","title":"Heun","text":"The two-step process used in Heun's method results in two calls of the dynamics function f being made. Therefore, the computational effort is about twice as large compared to Euler's method. However, in most cases, Heun's method is still very fast.","category":"page"},{"location":"integrators/heun/","page":"Heun","title":"Heun","text":"Compared to Euler's method, the accumulation of errors has a significantly lower effect when using Heun's method yielding much better results.","category":"page"},{"location":"functions/standalone_sim/#Standalone-Simulations","page":"Standalone Simulations","title":"Standalone Simulations","text":"","category":"section"},{"location":"functions/standalone_sim/#Continuous-Time-Simulations","page":"Standalone Simulations","title":"Continuous-Time Simulations","text":"","category":"section"},{"location":"functions/standalone_sim/#Dynamics-Model","page":"Standalone Simulations","title":"Dynamics Model","text":"","category":"section"},{"location":"functions/standalone_sim/","page":"Standalone Simulations","title":"Standalone Simulations","text":"The SimpleSim.jl equivalent of the first-order ordinary differential equation","category":"page"},{"location":"functions/standalone_sim/","page":"Standalone Simulations","title":"Standalone Simulations","text":"dotx(t) = f(x(t) u(t) p t)","category":"page"},{"location":"functions/standalone_sim/","page":"Standalone Simulations","title":"Standalone Simulations","text":"is to define a function that returns the current derivative","category":"page"},{"location":"functions/standalone_sim/","page":"Standalone Simulations","title":"Standalone Simulations","text":"function fc_my_model(x, u, p, t)\n    my_x_derivative = # ...\n    return my_x_derivative\nend","category":"page"},{"location":"functions/standalone_sim/","page":"Standalone Simulations","title":"Standalone Simulations","text":"Implicit differential equations 0 = F(dotx x u p t) are not supported.","category":"page"},{"location":"functions/standalone_sim/#Measurement-Model","page":"Standalone Simulations","title":"Measurement Model","text":"","category":"section"},{"location":"functions/standalone_sim/","page":"Standalone Simulations","title":"Standalone Simulations","text":"y(t) = g(x(t) u(t) p t)","category":"page"},{"location":"functions/standalone_sim/","page":"Standalone Simulations","title":"Standalone Simulations","text":"function yc_my_model(x, u, p, t)\n    my_output = # ...\n    return my_output\nend","category":"page"},{"location":"functions/standalone_sim/#Model-Creation","page":"Standalone Simulations","title":"Model Creation","text":"","category":"section"},{"location":"functions/standalone_sim/#Running-the-Simulation","page":"Standalone Simulations","title":"Running the Simulation","text":"","category":"section"},{"location":"functions/standalone_sim/#Discrete-Time-Simulations","page":"Standalone Simulations","title":"Discrete-Time Simulations","text":"","category":"section"},{"location":"functions/standalone_sim/#Dynamics-Model-2","page":"Standalone Simulations","title":"Dynamics Model","text":"","category":"section"},{"location":"functions/standalone_sim/","page":"Standalone Simulations","title":"Standalone Simulations","text":"x_k+1 = f(x_k u_k p t)","category":"page"},{"location":"functions/standalone_sim/","page":"Standalone Simulations","title":"Standalone Simulations","text":"function fd_my_model(x, u, p, t)\n    my_next_x = # ...\n    return my_next_x\nend","category":"page"},{"location":"functions/standalone_sim/#Measurement-Model-2","page":"Standalone Simulations","title":"Measurement Model","text":"","category":"section"},{"location":"functions/standalone_sim/","page":"Standalone Simulations","title":"Standalone Simulations","text":"y_k = g(x_k u_k p t)","category":"page"},{"location":"functions/standalone_sim/","page":"Standalone Simulations","title":"Standalone Simulations","text":"function yd_my_model(x, u, p, t)\n    my_output = # ...\n    return my_output\nend","category":"page"},{"location":"functions/standalone_sim/#Model-Creation-2","page":"Standalone Simulations","title":"Model Creation","text":"","category":"section"},{"location":"functions/standalone_sim/#Running-the-Simulation-2","page":"Standalone Simulations","title":"Running the Simulation","text":"","category":"section"},{"location":"functions/standalone_sim/","page":"Standalone Simulations","title":"Standalone Simulations","text":"out = simulate(my_model, T = T_end)","category":"page"},{"location":"functions/standalone_sim/","page":"Standalone Simulations","title":"Standalone Simulations","text":"Mandatory Keyword Arguments:","category":"page"},{"location":"functions/standalone_sim/","page":"Standalone Simulations","title":"Standalone Simulations","text":"T total time of the simulation","category":"page"},{"location":"functions/standalone_sim/","page":"Standalone Simulations","title":"Standalone Simulations","text":"Optional Keyword Arguments:","category":"page"},{"location":"functions/standalone_sim/","page":"Standalone Simulations","title":"Standalone Simulations","text":"t0 initial time, defaults to 0//1\nxd0 initial state, defaults to nothing. Overwrites initial state given in model.\nud input function  (t) -> some_input, if none is given, the input will be nothing for all times.","category":"page"},{"location":"functions/standalone_sim/","page":"Standalone Simulations","title":"Standalone Simulations","text":"Supported Keywords with no Effect for DT Simulations:","category":"page"},{"location":"functions/standalone_sim/","page":"Standalone Simulations","title":"Standalone Simulations","text":"uc input only used for continuous-time models\nxc0 initial state only used for continuous-time models\nintegator no integrator is used for discrete-time simulations\nΔt_max only relevant for integrators and therefore irrelevant for discrete-time models","category":"page"},{"location":"functions/standalone_sim/#Mixing-Continuous-Time-and-Discrete-Time-(Hybrid-Simulations)","page":"Standalone Simulations","title":"Mixing Continuous-Time and Discrete-Time (Hybrid Simulations)","text":"","category":"section"},{"location":"overview/exports/#Exports","page":"What does SimpleSim.jl export?","title":"Exports","text":"","category":"section"},{"location":"overview/exports/#Running-Simulations","page":"What does SimpleSim.jl export?","title":"Running Simulations","text":"","category":"section"},{"location":"overview/exports/","page":"What does SimpleSim.jl export?","title":"What does SimpleSim.jl export?","text":"simulate(model)","category":"page"},{"location":"overview/exports/#SimpleSim.simulate-Tuple{Any}","page":"What does SimpleSim.jl export?","title":"SimpleSim.simulate","text":"simulate(model; kwargs...)\n\nRuns the simulation for the given model.\n\nReturns a NamedTuple with all time-series information about the simulation.\n\nMandatory Keyword Arguments\n\nT: Total time of the simulation. Mand\n\nOptional Keyword Arguments\n\nuc: Expects a function (t) -> u defining the input to a continuous-time model at time t. Defaults to (t) -> nothing.\nud: Expects a function (t) -> u defining the input to a discrete-time model at time t. Defaults to (t) -> nothing.\nΔt_max: Maximum step size used for continuous-time model integration. Defaults to ΔT_DEFAULT set in SimpleSim.jl.\nt0: Initial time. Defaults to 0 // 1.\nxc0: Initial state for continuous-time model. Overwrites any initial state defined in the model itself. Defaults to nothing.\nxd0: Initial state for discrete-time model. Overwrites any initial state defined in the model itself. Defaults to nothing.\nintegrator: Integration method to be used for continuous-time models. See below for supported integrators. Defaults to RK4.\noptions: See below for additional options that can be set.\n\nSupported Numerical Integration Methods\n\nThese options can be passed to the simulate function as the integrator keyword argument:\n\n@enum SimpleSimIntegrator RK4 = 1 Euler = 2 Heun = 3 RKF45 = 4\n\nOptions\n\nSimpleSim.jl has a few default parameters for running simulations that generally do not need to be changed. However, if necessary the following options can be passed in a NamedTuple to the options keyword argument.\n\nΔt_default: replaces the default (maximum) step size used for continuous-time integration. Should be rational.   Defaults to 1 // 100.\nΔt_min: replaces the minimum step size used for continuous-time integration. Especially relevant for adaptive step size integrators.   Defaults to 1 // 1_000_000.\nzero_crossing_tol: absolute tolerance used when computing the time of a zero-crossing.   Defaults to 1e-5.\nRKF45_rel_tol: relative tolerance between the truncation error and the 5th order Runge-Kutta estimate leading to termination of the RKF45 integrator.   Defaults to 1e-6.\nRKF45_abs_tol: absolute tolerance for the truncation error leading to termination of the RKF45 integrator.   Defaults to 1e-7.\nsilent: if set to true all output, including warnings and erros is disabled.   To only print erros and warnings and disable all other output set display_progress and debug to false.   Defaults to false.\ndebug: set to true to get additional information printed in the terminal that might help you debug your models.   Defaults to false.\ndisplay_progress: set to false if you don't want to be updated about simulation progress in the terminal.   Defaults to true.\nprogress_spacing: time between progress updates in the terminal.   Defaults to 1 // 1.\nbase_rng: random number generator used for random draw functions.   Defaults to MersenneTwister.\nout_stream: IO stream used for console output.   Defaults to stdout.\n\nExample with Options\n\nout = simulate(my_model,\n    T = 20 // 1,\n    options = (\n        silent = true,\n        base_rng = Xoshiro,\n    )\n)\n\n\n\n\n\n","category":"method"},{"location":"overview/exports/#Updating-Submodels","page":"What does SimpleSim.jl export?","title":"Updating Submodels","text":"","category":"section"},{"location":"overview/exports/","page":"What does SimpleSim.jl export?","title":"What does SimpleSim.jl export?","text":"@call!","category":"page"},{"location":"overview/exports/#SimpleSim.@call!","page":"What does SimpleSim.jl export?","title":"SimpleSim.@call!","text":"@call! model u\n\nThe @call! macro is crucial for running simulations with submodels. In the parent model's yc or yd function every one of its submodels must be called using @call!. Otherwise the submodels will not be updated.\n\nReturns the output of model after the update. Use @state after calling @call! to access the new state.\n\nExample\n\nfunction yc_parent_model(x, u, p, t; models)\n    # ...\n    y_child = @call! models[1] u_child\n    # ...\nend\n\nNote: The @call! must not be used inside a dynamics (fc / fd) function. This will throw an error. If you need access to a submodels output/state inside your parent model's dynamics function use @out / @state.\n\n\n\n\n\n","category":"macro"},{"location":"overview/exports/","page":"What does SimpleSim.jl export?","title":"What does SimpleSim.jl export?","text":"@call_ct!","category":"page"},{"location":"overview/exports/#SimpleSim.@call_ct!","page":"What does SimpleSim.jl export?","title":"SimpleSim.@call_ct!","text":"@call_ct! model u\n\nThis macro should be used instead of @call! for calling the continuous-time dynamics of a hybrid model. This prevents ambiguity. See @call!.\n\n\n\n\n\n","category":"macro"},{"location":"overview/exports/","page":"What does SimpleSim.jl export?","title":"What does SimpleSim.jl export?","text":"@call_dt!","category":"page"},{"location":"overview/exports/#SimpleSim.@call_dt!","page":"What does SimpleSim.jl export?","title":"SimpleSim.@call_dt!","text":"@call_dt! model u\n\nThis macro should be used instead of @call! for calling the discrete-time dynamics of a hybrid model. This prevents ambiguity. See @call!.\n\n\n\n\n\n","category":"macro"},{"location":"overview/exports/#Access-to-Submodel-Output","page":"What does SimpleSim.jl export?","title":"Access to Submodel Output","text":"","category":"section"},{"location":"overview/exports/","page":"What does SimpleSim.jl export?","title":"What does SimpleSim.jl export?","text":"@out","category":"page"},{"location":"overview/exports/#SimpleSim.@out","page":"What does SimpleSim.jl export?","title":"SimpleSim.@out","text":"@out model\n\nReturns the current output of model. This macro is useful in fc or fd functions when access to a submodel's output is needed. The macro works similar to @state.\n\nExample\n\nfunction fc_parent_model(x, u, p, t; models)\n    y_child = @out models[1]\n    # ...\nend\n\nNote: @out does not update the model. It only returns its current output. Use @call! to update submodels.\n\n\n\n\n\n","category":"macro"},{"location":"overview/exports/","page":"What does SimpleSim.jl export?","title":"What does SimpleSim.jl export?","text":"@out_ct","category":"page"},{"location":"overview/exports/#SimpleSim.@out_ct","page":"What does SimpleSim.jl export?","title":"SimpleSim.@out_ct","text":"@out_ct model\n\nReturns the output of a given continuous-time model. Especially useful when retrieving the output of a hybrid model in which case @out would be ambiguous. See @out.\n\n\n\n\n\n","category":"macro"},{"location":"overview/exports/","page":"What does SimpleSim.jl export?","title":"What does SimpleSim.jl export?","text":"@out_dt","category":"page"},{"location":"overview/exports/#SimpleSim.@out_dt","page":"What does SimpleSim.jl export?","title":"SimpleSim.@out_dt","text":"@out_dt model\n\nReturns the output of a given discrete-time model. Especially useful when retrieving the output of a hybrid model in which case @out would be ambiguous. See @out.\n\n\n\n\n\n","category":"macro"},{"location":"overview/exports/#Access-to-Submodel-State","page":"What does SimpleSim.jl export?","title":"Access to Submodel State","text":"","category":"section"},{"location":"overview/exports/","page":"What does SimpleSim.jl export?","title":"What does SimpleSim.jl export?","text":"@state","category":"page"},{"location":"overview/exports/#SimpleSim.@state","page":"What does SimpleSim.jl export?","title":"SimpleSim.@state","text":"@state model\n\nReturns the current state of model. This macro is useful in fc or fd functions when access to a submodel's state is needed. The macro works similar to @out.\n\nNote: @state does not update the model. It only returns its current state. Use @call! to update submodels.\n\nExample\n\nfunction fc_parent_model(x, u, p, t; models)\n    x_child = @state models[1]\n    # ...\nend\n\n\n\n\n\n","category":"macro"},{"location":"overview/exports/","page":"What does SimpleSim.jl export?","title":"What does SimpleSim.jl export?","text":"@state_ct","category":"page"},{"location":"overview/exports/#SimpleSim.@state_ct","page":"What does SimpleSim.jl export?","title":"SimpleSim.@state_ct","text":"@state_ct model\n\nReturns the state of a given contiuous-time model. Especially useful when retrieving the state of a hybrid model in which case @state would be ambiguous. See @state.\n\n\n\n\n\n","category":"macro"},{"location":"overview/exports/","page":"What does SimpleSim.jl export?","title":"What does SimpleSim.jl export?","text":"@state_dt","category":"page"},{"location":"overview/exports/#SimpleSim.@state_dt","page":"What does SimpleSim.jl export?","title":"SimpleSim.@state_dt","text":"@state_dt model\n\nReturns the state of a given discrete-time model. Especially useful when retrieving the state of a hybrid model in which case @state would be ambiguous. See @state.\n\n\n\n\n\n","category":"macro"},{"location":"overview/exports/#Convenience-Functions","page":"What does SimpleSim.jl export?","title":"Convenience Functions","text":"","category":"section"},{"location":"overview/exports/","page":"What does SimpleSim.jl export?","title":"What does SimpleSim.jl export?","text":"print_model_tree","category":"page"},{"location":"overview/exports/#SimpleSim.print_model_tree","page":"What does SimpleSim.jl export?","title":"SimpleSim.print_model_tree","text":"print_model_tree(model; io = stdout)\n\nPrints a tree of the given model similar to a folder tree printed by the Linux tree command.\n\nAn example for a feedback-controlled inverted pendulum could look like this\n\njulia> print_model_tree(my_model)\n└─1 (TypeCT): top-level model / FeedbackSystem\n  ├─2 (TypeCT): .inverted_pendulum / NamedTuple\n  └─3 (TypeCT): .controller / NamedTuple\n\nFirst, the model_id is indicated, following the type (TypeCT, TypeDT or TypeHybrid). Then follows the name of each model in the super model. This is either its field name in the NamedTuple passed as models or the index in the case of vectors or tuples. Finally, after the slash, the type of each model is indicated. This should either be the name of a struct type, or NamedTuple.\n\nYou can also pass your own IO stream to print_model_tree as follows\n\nprint_model_tree(my_buffer, model)\n\n\n\n\n\n","category":"function"},{"location":"functions/nested_sim/#Nested-Simulations","page":"Nested Simulations","title":"Nested Simulations","text":"","category":"section"},{"location":"examples/four_rotor_drone/#Four-Rotor-Drone","page":"Four-Rotor Drone","title":"Four-Rotor Drone","text":"","category":"section"},{"location":"examples/four_rotor_drone/","page":"Four-Rotor Drone","title":"Four-Rotor Drone","text":"In this example, a four-rotor drone, just as the ones you can buy from various manufacturers, is set up. The drone involves the following individual models:","category":"page"},{"location":"examples/four_rotor_drone/","page":"Four-Rotor Drone","title":"Four-Rotor Drone","text":"a rigid body\nmotors\npropellers\nsensors\na control system","category":"page"},{"location":"examples/four_rotor_drone/","page":"Four-Rotor Drone","title":"Four-Rotor Drone","text":"Some of these models only consist of continuous-time or discrete-time dynamics, other might have both.","category":"page"},{"location":"examples/four_rotor_drone/","page":"Four-Rotor Drone","title":"Four-Rotor Drone","text":"Of course, the system's complexity can be increased arbitrarily.","category":"page"},{"location":"examples/four_rotor_drone/#Motors","page":"Four-Rotor Drone","title":"Motors","text":"","category":"section"},{"location":"examples/four_rotor_drone/","page":"Four-Rotor Drone","title":"Four-Rotor Drone","text":"The motors' RPM are modeled as second-order systems with time-constant tau, damping zeta and gain k.","category":"page"},{"location":"examples/four_rotor_drone/","page":"Four-Rotor Drone","title":"Four-Rotor Drone","text":"tau fracd^2 omegad t^2 + 2 zeta tau fracdomegadt + omega = k cdot r_omega(t)","category":"page"},{"location":"examples/four_rotor_drone/","page":"Four-Rotor Drone","title":"Four-Rotor Drone","text":"The reference RPM supplied by the control system forms the motor input.","category":"page"},{"location":"examples/four_rotor_drone/","page":"Four-Rotor Drone","title":"Four-Rotor Drone","text":"For SimpleSim.jl we need to cast this ODE into a system of first-order ODEs. The state then consists of the RPM omega and its derivative dotomega.","category":"page"},{"location":"examples/four_rotor_drone/","page":"Four-Rotor Drone","title":"Four-Rotor Drone","text":"function fc_motor(ω, r_ω, p, t)\n    ω_d = ω[2]\n    ω_dd = (p.k * r_ω - 2 * p.ζ * p.τ * ω[1]) / p.τ\n\n    if ω[1] >= p.rpm_max || ω[1] <= 0.0\n        ω_d = 0.0\n        ω_dd = 0.0\n    end\n\n    return [ω_d, ω_dd]\nend","category":"page"},{"location":"examples/four_rotor_drone/","page":"Four-Rotor Drone","title":"Four-Rotor Drone","text":"The output only contains the current RPM.","category":"page"},{"location":"examples/four_rotor_drone/","page":"Four-Rotor Drone","title":"Four-Rotor Drone","text":"yc_motor = (ω, r_ω, p, t) -> p.direction * ω[1]","category":"page"},{"location":"examples/four_rotor_drone/","page":"Four-Rotor Drone","title":"Four-Rotor Drone","text":"We can then create a motor model. The parameters tau, zeta and k are identified using system identification techniques. All motors are assumed to standing still at the beginning of the simulation.","category":"page"},{"location":"examples/four_rotor_drone/","page":"Four-Rotor Drone","title":"Four-Rotor Drone","text":"motor_1 = (\n    p = (\n        τ = 1 / 800.0^2,\n        ζ = 0.15,\n        k = 1.0,\n        rpm_max = 20_000*2*π,\n        direction = 1.0,\n    ),\n    fc = fc_motor,\n    yc = yc_motor,\n    xc0 = [0.0, 0.0],\n    uc0 = 0.0,\n)","category":"page"},{"location":"examples/four_rotor_drone/","page":"Four-Rotor Drone","title":"Four-Rotor Drone","text":"All four motors are basically identical. Hence, we copy the model we already have to get all four motor models.","category":"page"},{"location":"examples/four_rotor_drone/","page":"Four-Rotor Drone","title":"Four-Rotor Drone","text":"motor_2 = motor_1\nmotor_3 = motor_1\nmotor_4 = motor_1","category":"page"},{"location":"examples/four_rotor_drone/","page":"Four-Rotor Drone","title":"Four-Rotor Drone","text":"We only need to adjust the direction of rotation for motor 2 and 4.","category":"page"},{"location":"examples/four_rotor_drone/","page":"Four-Rotor Drone","title":"Four-Rotor Drone","text":"motor_2 = (motor_2..., p = (motor_2.p..., direction = -1.0))\nmotor_4 = (motor_4..., p = (motor_4.p..., direction = -1.0))","category":"page"},{"location":"examples/four_rotor_drone/","page":"Four-Rotor Drone","title":"Four-Rotor Drone","text":"Note: we are speaking about RPM, but ω is actually measured in radians per second.","category":"page"},{"location":"examples/four_rotor_drone/#Propellers","page":"Four-Rotor Drone","title":"Propellers","text":"","category":"section"},{"location":"examples/four_rotor_drone/","page":"Four-Rotor Drone","title":"Four-Rotor Drone","text":"We expect propellers to generate linear force (thrust) and torque as a function of the current RPM of the rotor. RPM is therefore an input of a rotor model, thrust and torque are the output.","category":"page"},{"location":"examples/four_rotor_drone/","page":"Four-Rotor Drone","title":"Four-Rotor Drone","text":"Thrust always acts downwards in the drone's frame of reference. Torque depends only on the direction of rotation of the propeller. Hence, we can use scalar values as ouputs of the propeller model.","category":"page"},{"location":"examples/four_rotor_drone/","page":"Four-Rotor Drone","title":"Four-Rotor Drone","text":"fc_prop = (x, ω, p, t) -> nothing\n\nyc_prop = (x, ω, p, t) -> [p.k_f2 * ω^2, p.k_t * ω]","category":"page"},{"location":"examples/four_rotor_drone/","page":"Four-Rotor Drone","title":"Four-Rotor Drone","text":"We expect thrust to be proportional to the square of the rate of rotation, while torque behaves approximately linear with respect to omega. The slopes k_f 2 and k_t are given as parameters.","category":"page"},{"location":"examples/four_rotor_drone/","page":"Four-Rotor Drone","title":"Four-Rotor Drone","text":"prop_1 = (\n    p = (\n        k_f2 = 5e-7,\n        k_t = 2e-5,\n    ),\n    fc = fc_prop,\n    yc = yc_prop,\n    uc0 = 0.0,\n)\nprop_2 = prop_1\nprop_3 = prop_1\nprop_4 = prop_1","category":"page"},{"location":"examples/four_rotor_drone/#RPM-Sensors","page":"Four-Rotor Drone","title":"RPM Sensors","text":"","category":"section"},{"location":"examples/four_rotor_drone/","page":"Four-Rotor Drone","title":"Four-Rotor Drone","text":"We assume the motors provide RPM feedback. But the sensor for that is digital and only updates at a frequency of 100Hz.","category":"page"},{"location":"examples/four_rotor_drone/","page":"Four-Rotor Drone","title":"Four-Rotor Drone","text":"fd_sensor = (x, ω, p, t) -> nothing\n\nyd_sensor = (x, ω, p, t) -> ω\n\nsensor_1 = (\n    p = nothing,\n    fd = fd_sensor,\n    yd = yd_sensor,\n    Δt = 1 // 100,\n    ud0 = 0.0,\n)\nsensor_2 = sensor_1\nsensor_3 = sensor_1\nsensor_4 = sensor_1","category":"page"},{"location":"examples/four_rotor_drone/","page":"Four-Rotor Drone","title":"Four-Rotor Drone","text":"Naturally, all sensors should be purely discrete-time.","category":"page"},{"location":"examples/four_rotor_drone/#\"Powered\"-Propellers","page":"Four-Rotor Drone","title":"\"Powered\" Propellers","text":"","category":"section"},{"location":"examples/four_rotor_drone/","page":"Four-Rotor Drone","title":"Four-Rotor Drone","text":"This model is not strictly necessary. However, to showcase the modularity of SimpleSim.jl we will wrap a motor, propeller and RPM sensor","category":"page"},{"location":"examples/four_rotor_drone/","page":"Four-Rotor Drone","title":"Four-Rotor Drone","text":"fc_powered_prop = (x, u, p, t; models) -> nothing\n\nfunction yc_powered_prop(x, r_ω, p, t; models)\n    ω = @call! models.motor r_ω\n    ft = @call! models.prop ω\n    ω_measurement = @call! models.sensor ω\n\n    return [ft..., ω_measurement...]\nend\n\npowered_prop_1 = (\n    p = nothing,\n    fc = fc_powered_prop,\n    yc = yc_powered_prop,\n    uc0 = 0.0,\n    models = (\n        motor = motor_1,\n        prop = prop_1,\n        sensor = rpm_sensor_1,\n    )\n)\n\npowered_prop_2 = (powered_prop_1...,\n    models = (\n        motor = motor_2,\n        prop = prop_2,\n        sensor = rpm_sensor_2,\n    )\n)\n\npowered_prop_3 = # ...","category":"page"},{"location":"examples/four_rotor_drone/","page":"Four-Rotor Drone","title":"Four-Rotor Drone","text":"A powered_prop is a continuous-time model, taking a reference RPM as input. It then calls the motor model, computes the thrust and torque generated using the prop model and returns the force, torque and the sensor measurement of the current RPM.","category":"page"},{"location":"examples/four_rotor_drone/#Airframe","page":"Four-Rotor Drone","title":"Airframe","text":"","category":"section"},{"location":"examples/four_rotor_drone/","page":"Four-Rotor Drone","title":"Four-Rotor Drone","text":"To gather the motor and propeller models, we define a state-less airframe model that simply computes the overall force and torque acting on the system, given four reference RPM values.","category":"page"},{"location":"examples/four_rotor_drone/","page":"Four-Rotor Drone","title":"Four-Rotor Drone","text":"Note, that since the propellers are excerted from the drone's center of gravity they need to be included in the computation of the total torque acting on the system.","category":"page"},{"location":"examples/four_rotor_drone/","page":"Four-Rotor Drone","title":"Four-Rotor Drone","text":"fc_airframe = (x, u, p, t; models) -> nothing\n\nfunction yc_airframe(x, r_ω, p, t; models)\n    ft_ω_1 = @call! models.powered_prop_1 r_ω[1]\n    ft_ω_2 = @call! models.powered_prop_2 r_ω[2]\n    ft_ω_3 = @call! models.powered_prop_3 r_ω[3]\n    ft_ω_4 = @call! models.powered_prop_4 r_ω[4]\n\n    # compute the total thrust in the drone's frame of reference\n    f_total_B = [0, 0, - ft_ω_1[1] - ft_ω_2[1] - ft_ω_3[1] - ft_ω_4[1]]\n\n    # compute total total torque\n    t_aero_B = [0, 0, ft_ω_1[2] + ft_ω_2[2] + ft_ω_3[2] + ft_ω_4[2]]\n    t_thrust_B = p.x_prop_1_B × [0, 0, ft_ω_1[1]] + p.x_prop_2_B × [0, 0, ft_ω_2[1]] + p.x_prop_3_B × [0, 0, ft_ω_3[1]] + p.x_prop_4_B × [0, 0, ft_ω_4[1]]\n\n    return vcat(f_total_B, t_aero_B + t_thrust_B, ft_ω_1[end], ft_ω_2[end], ft_ω_3[end], ft_ω_4[end])\nend\n\nairframe = (\n    p = (\n        x_prop_1_B = [10e-2, 10e-2, 0.0],\n        x_prop_2_B = [-10e-2, 10e-2, 0.0],\n        x_prop_3_B = [-10e-2, -10e-2, 0.0],\n        x_prop_4_B = [10e-2, -10e-2, 0.0],\n    ),\n    fc = fc_airframe,\n    yc = yc_airframe,\n    uc0 = [0.0, 0.0, 0.0, 0.0],\n    models = (\n        powered_prop_1 = powered_prop_1,\n        powered_prop_2 = powered_prop_2,\n        powered_prop_3 = powered_prop_3,\n        powered_prop_4 = powered_prop_4,\n    ),\n)","category":"page"},{"location":"examples/four_rotor_drone/#The-Rigid-Body","page":"Four-Rotor Drone","title":"The Rigid Body","text":"","category":"section"},{"location":"examples/four_rotor_drone/","page":"Four-Rotor Drone","title":"Four-Rotor Drone","text":"The drone itself of course has rigid body dynamics. These are pretty straigtforward to model.","category":"page"},{"location":"examples/four_rotor_drone/","page":"Four-Rotor Drone","title":"Four-Rotor Drone","text":"The rigid-body inputs are the sum of all forces and moments acting on the body in its own frame of reference. The output is its current position and velocity in the inertial frame and its Euler angles, as well as angular rates.","category":"page"},{"location":"examples/four_rotor_drone/","page":"Four-Rotor Drone","title":"Four-Rotor Drone","text":"function fc_rigid_body(x, u, p, t)\n\nend\n\nyc_rigid_body = (x, u, p, t) -> x\n\nrigid_body = (\n    p = (\n        m = 0.3,\n        J = [\n\n        ],\n    ),\n    fc = fc_rigid_body,\n    yc = yc_rigid_body,\n    xc0 = [],\n    uc0 = [],\n)","category":"page"},{"location":"examples/four_rotor_drone/#GPS,-Accelerometer-and-Gyroscope","page":"Four-Rotor Drone","title":"GPS, Accelerometer and Gyroscope","text":"","category":"section"},{"location":"examples/four_rotor_drone/#The-Control-System","page":"Four-Rotor Drone","title":"The Control System","text":"","category":"section"},{"location":"examples/four_rotor_drone/#Putting-it-all-together","page":"Four-Rotor Drone","title":"Putting it all together","text":"","category":"section"},{"location":"examples/four_rotor_drone/","page":"Four-Rotor Drone","title":"Four-Rotor Drone","text":"the_drone = (\n    models = (\n        airframe = airframe,\n    )\n)","category":"page"},{"location":"overview/run_sims/#Running-Simulations","page":"Simulating Models","title":"Running Simulations","text":"","category":"section"},{"location":"integrators/rk4/#4th-Order-Runge-Kutta-Method-/-RK4","page":"4th Order Runge-Kutta","title":"4th Order Runge-Kutta Method / RK4","text":"","category":"section"},{"location":"integrators/rk4/#Usage","page":"4th Order Runge-Kutta","title":"Usage","text":"","category":"section"},{"location":"integrators/rk4/","page":"4th Order Runge-Kutta","title":"4th Order Runge-Kutta","text":"The desired integration method used for continuous-time dynamics is passed to the simulate function as a keyword argument.","category":"page"},{"location":"integrators/rk4/","page":"4th Order Runge-Kutta","title":"4th Order Runge-Kutta","text":"using SimpleSim\n\n# my_model = ...\n\nout = simulate(my_model, T = T_end, integrator = RK4)","category":"page"},{"location":"integrators/rk4/#Mathematical-Background","page":"4th Order Runge-Kutta","title":"Mathematical Background","text":"","category":"section"},{"location":"integrators/rk4/","page":"4th Order Runge-Kutta","title":"4th Order Runge-Kutta","text":"As the name suggests, this method is a four-step algorithm.","category":"page"},{"location":"integrators/rk4/","page":"4th Order Runge-Kutta","title":"4th Order Runge-Kutta","text":"First, the derivative function f is evaluated at four different points.","category":"page"},{"location":"integrators/rk4/","page":"4th Order Runge-Kutta","title":"4th Order Runge-Kutta","text":"k_1 = f(x u(t) p t)","category":"page"},{"location":"integrators/rk4/","page":"4th Order Runge-Kutta","title":"4th Order Runge-Kutta","text":"k_2 = f(x + fracDelta t2 k_1 u(t + fracDelta t2) p t + fracDelta t2)","category":"page"},{"location":"integrators/rk4/","page":"4th Order Runge-Kutta","title":"4th Order Runge-Kutta","text":"k_3 = f(x + fracDelta t2 k_2 u(t + fracDelta t2) p t + fracDelta t2)","category":"page"},{"location":"integrators/rk4/","page":"4th Order Runge-Kutta","title":"4th Order Runge-Kutta","text":"k_4 = f(x + Delta tcdot k_3 u(t + Delta t) p t + Delta t)","category":"page"},{"location":"integrators/rk4/","page":"4th Order Runge-Kutta","title":"4th Order Runge-Kutta","text":"The RK4 estimate of the state at time t + Delta t is then given by the weighted average.","category":"page"},{"location":"integrators/rk4/","page":"4th Order Runge-Kutta","title":"4th Order Runge-Kutta","text":"x^+ = x + fracDelta t6 (k_1 + 2 k_2 + 2 k_3 + k_4)","category":"page"},{"location":"integrators/rk4/#Performance","page":"4th Order Runge-Kutta","title":"Performance","text":"","category":"section"},{"location":"integrators/rk4/","page":"4th Order Runge-Kutta","title":"4th Order Runge-Kutta","text":"The fourth-order Runge-Kutta method requires four calls of the dynamics function and is therefore the slowest out of all fixed step-size methods provided by SimpleSim.jl.","category":"page"},{"location":"integrators/rk4/","page":"4th Order Runge-Kutta","title":"4th Order Runge-Kutta","text":"In most cases, however, the evaluation of f is fast enought so that RK4 can be used as the standard integration method.","category":"page"},{"location":"integrators/rk4/","page":"4th Order Runge-Kutta","title":"4th Order Runge-Kutta","text":"The advantages in terms of precision compared to first and second order methods are imense and generally RK4 is sufficiently exact.","category":"page"},{"location":"integrators/rk4/","page":"4th Order Runge-Kutta","title":"4th Order Runge-Kutta","text":"In rare cases, however, an adaptive step-size variation of RK4 should be used. See the chapter about Runge-Kutta-Fehlberg for more information.","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"SimpleSim.jl is a minimalist Julia framework for modular dynamical system simulation.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For installation, run import Pkg; Pkg.add(\"SimpleSim.jl\") from within your Julia environment.","category":"page"},{"location":"#Philosophy","page":"Introduction","title":"Philosophy","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This software project aims at removing a lot of the overhead that a lot of the existing simulation frameworks out there have. SimpleSim.jl does not export any types. The interface almost solely consists of the function simulate and a agreed-upon model structure. The light interface results in most design decisions left up to the user.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"At the same time SimpleSim.jl does not compromise on functionality and offers a feature-rich simulation framework.","category":"page"},{"location":"#Short-overview","page":"Introduction","title":"Short overview","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The main point of interaction with the SimpleSim.jl framework is the simulate function. As a first argument it expects to be passed some object that provides hooks with certain names for various functionalities.","category":"page"},{"location":"#Continuous-Time-Systems","page":"Introduction","title":"Continuous-Time Systems","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"A simple example of a dynamical systems model accepted by SimpleSim.jl would be","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"my_model = (\n    p = nothing,\n    fc = dynamics_function,\n    yc = measurement_function,\n)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"where we pass nothing as the parameters of the model (i.e. we don't need any parameters right now) and two functions dynamics_function and measurement_function that we defined elsewhere.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"These two functions follow the typical dynamical systems approach for continuous-time systems","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"dotx(t) = f(x(t) u(t) p t)\ny(t) = g(x(t) u(t) p t)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"or in Julia","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"dynamics_function = (x, u, p t) -> ...\nmeasurement_function = (x, u, p t) -> ...","category":"page"},{"location":"#Discrete-Time-Systems","page":"Introduction","title":"Discrete-Time Systems","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Similarly for a discrete-time system we write","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"next_state_function = (x, u, p, t) -> ...\ndt_measurement_function = (x, u, p, t) -> ...\n\nmy_dt_model = (\n    p = nothing,\n    fd = next_state_function,\n    yd = dt_measurement_function,\n    Δt = 1 // 10,\n)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"modeling the system","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"x_k+1 = f(x_k u_k p t)\ny_k = g(x_k u_k p t)","category":"page"},{"location":"#Running-Simulations","page":"Introduction","title":"Running Simulations","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Simulating a model is done by calling the simulate function","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"out = simulate(my_model, T = 10 // 1)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"add the keyword argument xc0 = or xd0 = to set the initial state of your continuous-time or discrete-time model, respectively.","category":"page"},{"location":"#Modularity","page":"Introduction","title":"Modularity","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"SimpleSim.jl takes a hierarchical approach to more complex, modular systems. That means any model can have any number of submodels. To define submodels, a Vector, Tuple or NamedTuple of models is passed to the models keywords on creation of the model.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"submodel_1 = (\n    p = nothing,\n    fc = ...,\n    yc = ...,\n)\n\nsubmodel_2 = ...\n\nparent_model = (\n    p = nothing,\n    fc = fc_parent,\n    yc = yc_parent,\n    models = (\n        model_1 = submodel_1,\n        model_2 = submodel_2,\n    )\n)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Now, parent_model has two submodels. Note, that submodels are not updated automatically. They have to be called by their parent model. Only the top-level model passed to simulate is actively updated by SimpleSim.jl.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For calling a submodel, use the @call! macro from within a yc function and add the input you want to give the submodel.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"function yc_parent(x, u, p, t; models)\n    u_1 = ...\n    y_submodel_1 = @call! models.model_1 u_1\n\n    u_2 = ...\n    y_submodel_2 = @call! models.model_2 u_2\n\n    return ...\nend","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Calls can only be made from within a yc function. Not from within an fc function. To obtain the current output of a submodel without updating it, use the @out macro.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"function fc_parent(x, u, p, t; models)\n    y_1 = @out models.model_1\n    # ...\nend","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Discrete-time systems work in the same way. However, SimpleSim.jl makes sure that discrete-time models are only updated according to their update frequency.","category":"page"},{"location":"#Citing","page":"Introduction","title":"Citing","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"If you used SimpleSim.jl in research and you are preparing a publication, please use the following BiBTeX entry:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@software{SimpleSim,\n    author = {Huehnerbein, Jannes},\n    title = {{SimpleSim.jl: A minimalist Julia toolbox for modular dynamical systems simulation}},\n    url = {https://github.com/janneshb/SimpleSim.jl},\n    version = {0.1.0},\n    year = {2024},\n    month = {04},\n}","category":"page"}]
}
