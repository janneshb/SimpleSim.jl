var documenterSearchIndex = {"docs":
[{"location":"integrators/rkf45/#Runge-Kutta-Fehlberg-Method-/-RKF45","page":"Runge-Kutta-Fehlberg","title":"Runge-Kutta-Fehlberg Method / RKF45","text":"","category":"section"},{"location":"integrators/rkf45/#Usage","page":"Runge-Kutta-Fehlberg","title":"Usage","text":"","category":"section"},{"location":"integrators/rkf45/","page":"Runge-Kutta-Fehlberg","title":"Runge-Kutta-Fehlberg","text":"The desired integration method used for continuous-time dynamics is passed to the simulate function as a keyword argument.","category":"page"},{"location":"integrators/rkf45/","page":"Runge-Kutta-Fehlberg","title":"Runge-Kutta-Fehlberg","text":"using SimpleSim\n\n# my_model = ...\n\nout = simulate(my_model, T = T_end, integrator = RKF45)","category":"page"},{"location":"integrators/rkf45/#Mathematical-Background","page":"Runge-Kutta-Fehlberg","title":"Mathematical Background","text":"","category":"section"},{"location":"integrators/rkf45/","page":"Runge-Kutta-Fehlberg","title":"Runge-Kutta-Fehlberg","text":"The Runge-Kutta-Fehlberg method, also known as Fehlberg's method or simply RKF45, is an adaptive step size solver for ordinary differential equations. The core idea of the method is to adjust the current step size by looking at the difference between the estimates using the 4th and 5th order Runge-Kutta methods.","category":"page"},{"location":"integrators/rkf45/","page":"Runge-Kutta-Fehlberg","title":"Runge-Kutta-Fehlberg","text":"First, the 4th and 5th order Runge-Kutta estimates are computed. We denote these as x^+_textRK4 and x^+_textRK5, respectively. Given the coefficients k_1 through k_6, the two estimates can be computed as follows.","category":"page"},{"location":"integrators/rkf45/","page":"Runge-Kutta-Fehlberg","title":"Runge-Kutta-Fehlberg","text":"x^+_textRK4 = x + Delta t(frac25216 k_1 + frac14082565k_3 + frac21974101k_4 - frac15k_5)","category":"page"},{"location":"integrators/rkf45/","page":"Runge-Kutta-Fehlberg","title":"Runge-Kutta-Fehlberg","text":"x^+_textRK5 = x + Delta t(frac16135 k_1 + frac665612825k_3 + frac2856156430k_4 - frac950k_5 + frac255k_6)","category":"page"},{"location":"integrators/rkf45/","page":"Runge-Kutta-Fehlberg","title":"Runge-Kutta-Fehlberg","text":"Where the coefficients k_i are computed as","category":"page"},{"location":"integrators/rkf45/","page":"Runge-Kutta-Fehlberg","title":"Runge-Kutta-Fehlberg","text":"k_1 = f(x u(t) p t)","category":"page"},{"location":"integrators/rkf45/","page":"Runge-Kutta-Fehlberg","title":"Runge-Kutta-Fehlberg","text":"k_2 = f(x + fracDelta t4 k_1 u(t + fracDelta t4) p t + fracDelta t4)","category":"page"},{"location":"integrators/rkf45/","page":"Runge-Kutta-Fehlberg","title":"Runge-Kutta-Fehlberg","text":"k_3 = f(x + frac3Delta t32 k_1 + frac9Delta t32k_2 u(t + frac3Delta t8) p t + frac3Delta t8)","category":"page"},{"location":"integrators/rkf45/","page":"Runge-Kutta-Fehlberg","title":"Runge-Kutta-Fehlberg","text":"k_4 = f(x + frac1932Delta t2197k_1 - frac7200Delta t2197k_2 + frac7296Delta t2197 k_3 u(t + frac12Delta t13) p t+ frac12Delta t13)","category":"page"},{"location":"integrators/rkf45/","page":"Runge-Kutta-Fehlberg","title":"Runge-Kutta-Fehlberg","text":"k_5 = f(x + frac439Delta t216k_1 - 8Delta t k_2 + frac3680Delta t513k_3 - frac845 Delta t4104k_4 u(t + Delta t) p t + Delta t)","category":"page"},{"location":"integrators/rkf45/","page":"Runge-Kutta-Fehlberg","title":"Runge-Kutta-Fehlberg","text":"k_6 = f(x - frac8Delta t27 k_1 + 2Delta tk_2 - frac3544Delta t2565 + frac1859Delta t4104k_4 - frac11Delta t40k_5 u(t + fracDelta t2) p t + fracDelta t2)","category":"page"},{"location":"integrators/rkf45/","page":"Runge-Kutta-Fehlberg","title":"Runge-Kutta-Fehlberg","text":"After computing both estimates, the optimal adaptive step size Delta t_textopt can be computed using the following formula,","category":"page"},{"location":"integrators/rkf45/","page":"Runge-Kutta-Fehlberg","title":"Runge-Kutta-Fehlberg","text":"Delta t_textopt = Delta tcdot bigg(fracvarepsilon2lvert x^+_textRK4 - x^+_textRK5 rvertbigg)^025","category":"page"},{"location":"integrators/rkf45/","page":"Runge-Kutta-Fehlberg","title":"Runge-Kutta-Fehlberg","text":"where varepsilon denotes a desired tolerance.","category":"page"},{"location":"integrators/rkf45/","page":"Runge-Kutta-Fehlberg","title":"Runge-Kutta-Fehlberg","text":"SimpleSim.jl uses the following approximation","category":"page"},{"location":"integrators/rkf45/","page":"Runge-Kutta-Fehlberg","title":"Runge-Kutta-Fehlberg","text":"Delta t_textopt = 084cdot bigg(fracvarepsilon_textabslVert x^+_textRK4 - x^+_textRK5 rVert_inftybigg)^025","category":"page"},{"location":"integrators/rkf45/","page":"Runge-Kutta-Fehlberg","title":"Runge-Kutta-Fehlberg","text":"where the absolute tolerance is computed as","category":"page"},{"location":"integrators/rkf45/","page":"Runge-Kutta-Fehlberg","title":"Runge-Kutta-Fehlberg","text":"varepsilon_textabs = varepsilon_textrelcdot lVert x^+_textRK5rVert_2","category":"page"},{"location":"integrators/rkf45/","page":"Runge-Kutta-Fehlberg","title":"Runge-Kutta-Fehlberg","text":"and the relative tolerance is a constant simulation option called RKF45_REL_TOL.","category":"page"},{"location":"integrators/rkf45/","page":"Runge-Kutta-Fehlberg","title":"Runge-Kutta-Fehlberg","text":"You can read more about this on Wikipedia, on this great website by the University of Waterloo or in this very helpful excerpt from a text book on numerical methods by John Mathews and Kurtis Fink.","category":"page"},{"location":"integrators/rkf45/#Performance","page":"Runge-Kutta-Fehlberg","title":"Performance","text":"","category":"section"},{"location":"integrators/rkf45/","page":"Runge-Kutta-Fehlberg","title":"Runge-Kutta-Fehlberg","text":"For obivious reasons, Runge-Kutta-Fehlberg is the slowest method supported by SimpleSim.jl. The system dynamics function is called at least six times and for stiff problems the adaptive step size can get very small causing the simulation to become very slow.","category":"page"},{"location":"integrators/rkf45/","page":"Runge-Kutta-Fehlberg","title":"Runge-Kutta-Fehlberg","text":"However, for certain classes of problems, adaptive step size methods are absolutely necessary. Especially system's with sensitive dependence on initial conditions, i. e. chaotic systems, can be solved much faster and with higher precision using adaptive step size methods. The only alternative would be using a fixed step size method with a very small step size. This, however, would be computationally more expensive in a lot of cases.","category":"page"},{"location":"manual/api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"manual/api/#Running-Simulations","page":"API","title":"Running Simulations","text":"","category":"section"},{"location":"manual/api/","page":"API","title":"API","text":"simulate(model)","category":"page"},{"location":"manual/api/#SimpleSim.simulate-Tuple{Any}","page":"API","title":"SimpleSim.simulate","text":"simulate(model; kwargs...)\n\nRuns the simulation for the given model.\n\nReturns a NamedTuple with all time-series information about the simulation.\n\nMandatory Keyword Arguments\n\nT: Total time of the simulation. Mand\n\nOptional Keyword Arguments\n\nuc: Expects a function (t) -> u defining the input to a continuous-time model at time t. Defaults to (t) -> nothing.\nud: Expects a function (t) -> u defining the input to a discrete-time model at time t. Defaults to (t) -> nothing.\nΔt_max: Maximum step size used for continuous-time model integration. Defaults to ΔT_DEFAULT set in SimpleSim.jl.\nt0: Initial time. Defaults to 0 // 1.\nxc0: Initial state for continuous-time model. Overwrites any initial state defined in the model itself. Defaults to nothing.\nxd0: Initial state for discrete-time model. Overwrites any initial state defined in the model itself. Defaults to nothing.\nintegrator: Integration method to be used for continuous-time models. See below for supported integrators. Defaults to RK4.\noptions: See below for additional options that can be set.\n\nSupported Numerical Integration Methods\n\nThese options can be passed to the simulate function as the integrator keyword argument:\n\n@enum SimpleSimIntegrator RK4 = 1 Euler = 2 Heun = 3 RKF45 = 4\n\nOptions\n\nSimpleSim.jl has a few default parameters for running simulations that generally do not need to be changed. However, if necessary the following options can be passed in a NamedTuple to the options keyword argument.\n\nΔt_default: replaces the default (maximum) step size used for continuous-time integration. Should be rational.   Defaults to global parameter ΔT_DEFAULT.\nΔt_min: replaces the minimum step size used for continuous-time integration. Especially relevant for adaptive step size integrators.   Defaults to 1 // 1_000_000.\nzero_crossing_tol: absolute tolerance used when computing the time of a zero-crossing.   Defaults to 1e-5.\nRKF45_rel_tol: relative tolerance between the truncation error and the 5th order Runge-Kutta estimate leading to termination of the RKF45 integrator.   Defaults to 1e-6.\nRKF45_abs_tol: absolute tolerance for the truncation error leading to termination of the RKF45 integrator.   Defaults to 1e-7.\nsilent: if set to true all output, including warnings and erros is disabled.   To only print erros and warnings and disable all other output set display_progress and debug to false.   Defaults to false.\ndebug: set to true to get additional information printed in the terminal that might help you debug your models.   Defaults to false.\ndisplay_progress: set to false if you don't want to be updated about simulation progress in the terminal.   Defaults to true.\nprogress_spacing: time between progress updates in the terminal.   Defaults to 1 // 1.\nbase_rng: random number generator used for random draw functions.   Defaults to MersenneTwister.\nout_stream: IO stream used for console output.   Defaults to stdout.\n\nExample with Options\n\nout = simulate(my_model,\n    T = 20 // 1,\n    options = (\n        silent = true,\n        base_rng = Xoshiro,\n    )\n)\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Updating-Submodels","page":"API","title":"Updating Submodels","text":"","category":"section"},{"location":"manual/api/","page":"API","title":"API","text":"@call!","category":"page"},{"location":"manual/api/#SimpleSim.@call!","page":"API","title":"SimpleSim.@call!","text":"@call! model u\n\nThe @call! macro is crucial for running simulations with submodels. In the parent model's gc or gd function every one of its submodels must be called using @call!. Otherwise the submodels will not be updated.\n\nReturns the output of model after the update. Use @state after calling @call! to access the new state.\n\nExample\n\nfunction gc_parent_model(x, u, p, t; models)\n    # ...\n    y_child = @call! models[1] u_child\n    # ...\nend\n\nNote: The @call! must not be used inside a dynamics (fc / fd) function. This will throw an error. If you need access to a submodels output/state inside your parent model's dynamics function use @out / @state.\n\n\n\n\n\n","category":"macro"},{"location":"manual/api/","page":"API","title":"API","text":"@call_ct!","category":"page"},{"location":"manual/api/#SimpleSim.@call_ct!","page":"API","title":"SimpleSim.@call_ct!","text":"@call_ct! model u\n\nThis macro should be used instead of @call! for calling the continuous-time dynamics of a hybrid model. This prevents ambiguity. See @call!.\n\n\n\n\n\n","category":"macro"},{"location":"manual/api/","page":"API","title":"API","text":"@call_dt!","category":"page"},{"location":"manual/api/#SimpleSim.@call_dt!","page":"API","title":"SimpleSim.@call_dt!","text":"@call_dt! model u\n\nThis macro should be used instead of @call! for calling the discrete-time dynamics of a hybrid model. This prevents ambiguity. See @call!.\n\n\n\n\n\n","category":"macro"},{"location":"manual/api/#Access-to-Submodel-Output","page":"API","title":"Access to Submodel Output","text":"","category":"section"},{"location":"manual/api/","page":"API","title":"API","text":"@out","category":"page"},{"location":"manual/api/#SimpleSim.@out","page":"API","title":"SimpleSim.@out","text":"@out model\n\nReturns the current output of model. This macro is useful in fc or fd functions when access to a submodel's output is needed. The macro works similar to @state.\n\nExample\n\nfunction fc_parent_model(x, u, p, t; models)\n    y_child = @out models[1]\n    # ...\nend\n\nNote: @out does not update the model. It only returns its current output. Use @call! to update submodels.\n\n\n\n\n\n","category":"macro"},{"location":"manual/api/","page":"API","title":"API","text":"@out_ct","category":"page"},{"location":"manual/api/#SimpleSim.@out_ct","page":"API","title":"SimpleSim.@out_ct","text":"@out_ct model\n\nReturns the output of a given continuous-time model. Especially useful when retrieving the output of a hybrid model in which case @out would be ambiguous. See @out.\n\n\n\n\n\n","category":"macro"},{"location":"manual/api/","page":"API","title":"API","text":"@out_dt","category":"page"},{"location":"manual/api/#SimpleSim.@out_dt","page":"API","title":"SimpleSim.@out_dt","text":"@out_dt model\n\nReturns the output of a given discrete-time model. Especially useful when retrieving the output of a hybrid model in which case @out would be ambiguous. See @out.\n\n\n\n\n\n","category":"macro"},{"location":"manual/api/#Access-to-Submodel-State","page":"API","title":"Access to Submodel State","text":"","category":"section"},{"location":"manual/api/","page":"API","title":"API","text":"@state","category":"page"},{"location":"manual/api/#SimpleSim.@state","page":"API","title":"SimpleSim.@state","text":"@state model\n\nReturns the current state of model. This macro is useful in fc or fd functions when access to a submodel's state is needed. The macro works similar to @out.\n\nNote: @state does not update the model. It only returns its current state. Use @call! to update submodels.\n\nExample\n\nfunction fc_parent_model(x, u, p, t; models)\n    x_child = @state models[1]\n    # ...\nend\n\n\n\n\n\n","category":"macro"},{"location":"manual/api/","page":"API","title":"API","text":"@state_ct","category":"page"},{"location":"manual/api/#SimpleSim.@state_ct","page":"API","title":"SimpleSim.@state_ct","text":"@state_ct model\n\nReturns the state of a given contiuous-time model. Especially useful when retrieving the state of a hybrid model in which case @state would be ambiguous. See @state.\n\n\n\n\n\n","category":"macro"},{"location":"manual/api/","page":"API","title":"API","text":"@state_dt","category":"page"},{"location":"manual/api/#SimpleSim.@state_dt","page":"API","title":"SimpleSim.@state_dt","text":"@state_dt model\n\nReturns the state of a given discrete-time model. Especially useful when retrieving the state of a hybrid model in which case @state would be ambiguous. See @state.\n\n\n\n\n\n","category":"macro"},{"location":"manual/api/#Convenience-Functions","page":"API","title":"Convenience Functions","text":"","category":"section"},{"location":"manual/api/","page":"API","title":"API","text":"print_model_tree","category":"page"},{"location":"manual/api/#SimpleSim.print_model_tree","page":"API","title":"SimpleSim.print_model_tree","text":"print_model_tree(model; io = stdout)\n\nPrints a tree of the given model similar to a folder tree printed by the Linux tree command.\n\nAn example for a feedback-controlled inverted pendulum could look like this\n\njulia> print_model_tree(my_model)\n└─1 (TypeCT): top-level model / FeedbackSystem\n  ├─2 (TypeCT): .inverted_pendulum / NamedTuple\n  └─3 (TypeCT): .controller / NamedTuple\n\nFirst, the model_id is indicated, following the type (TypeCT, TypeDT or TypeHybrid). Then follows the name of each model in the super model. This is either its field name in the NamedTuple passed as models or the index in the case of vectors or tuples. Finally, after the slash, the type of each model is indicated. This should either be the name of a struct type, or NamedTuple.\n\nYou can also pass your own IO stream to print_model_tree as follows\n\nprint_model_tree(my_buffer, model)\n\n\n\n\n\n","category":"function"},{"location":"integrators/overview/#Continuous-Time-Intgration-Methods-–-An-Overview","page":"Overview","title":"Continuous-Time Intgration Methods – An Overview","text":"","category":"section"},{"location":"integrators/overview/#Available-Solving-Methods","page":"Overview","title":"Available Solving Methods","text":"","category":"section"},{"location":"integrators/overview/","page":"Overview","title":"Overview","text":"Forward Euler Euler\nHeun's Method Heun\nForth-Order Runge-Kutta Method RK4\nRunge-Kutta-Fehlberg-Method RKF45","category":"page"},{"location":"integrators/overview/","page":"Overview","title":"Overview","text":"The list is ordered by fastest to slowest and at the same time by least to most precise.","category":"page"},{"location":"integrators/overview/#Usage","page":"Overview","title":"Usage","text":"","category":"section"},{"location":"integrators/overview/","page":"Overview","title":"Overview","text":"Supported integration methods are exported by SimpleSim.jl as part of the enum SimpleSimIntegrator.","category":"page"},{"location":"integrators/overview/","page":"Overview","title":"Overview","text":"@enum SimpleSimIntegrator RK4 = 1 Euler = 2 Heun = 3 RKF45 = 4","category":"page"},{"location":"integrators/overview/","page":"Overview","title":"Overview","text":"To choose an integration method for simulation, use the integrator keyword argument when running a simulation.","category":"page"},{"location":"integrators/overview/","page":"Overview","title":"Overview","text":"out = simulate(my_model, T = T_end, integrator = Heun)","category":"page"},{"location":"integrators/overview/","page":"Overview","title":"Overview","text":"Fourth-order Runge-Kutta (RK4) is used by default.","category":"page"},{"location":"integrators/overview/#Step-Size-Computation","page":"Overview","title":"Step Size Computation","text":"","category":"section"},{"location":"integrators/overview/","page":"Overview","title":"Overview","text":"The step size Delta t stays constant over the whole duration of the simulation. It is computed as the minimum of Δt_max, a keyword argument of simulate, and the greatest common divisor of Δt_max and all Δt values given for all models in the simulation.","category":"page"},{"location":"integrators/overview/","page":"Overview","title":"Overview","text":"All continuous-time models that are part of the same simulation are updated at the same frequency determined by the \"fastest\" model in the simulation. This sampling time is determined by computing the greatest common rational divisor of all sampling times in the simulation. Apart performance concerns it is always better to update continuous-time models more frequently.","category":"page"},{"location":"integrators/overview/","page":"Overview","title":"Overview","text":"Example:","category":"page"},{"location":"integrators/overview/","page":"Overview","title":"Overview","text":"Assume you have set up a model that should be updated at least every twelfth of a second.","category":"page"},{"location":"integrators/overview/","page":"Overview","title":"Overview","text":"my_model = (\n    # ...\n    Δt = 1 // 12,\n)\n\nout = simulate(my_model, T = T_end, Δt_max = 1 // 20)","category":"page"},{"location":"integrators/overview/","page":"Overview","title":"Overview","text":"The fixed step size integrators will now be called with Δt = 1 // 60, which is the greatest common divisor of frac112 and frac120.","category":"page"},{"location":"integrators/overview/","page":"Overview","title":"Overview","text":"By default, Δt_max is set to 1 // 100 which is more than sufficient for most applications.","category":"page"},{"location":"integrators/euler/#Forward-Euler-Integration-/-Euler","page":"Euler","title":"Forward Euler Integration / Euler","text":"","category":"section"},{"location":"integrators/euler/#Usage","page":"Euler","title":"Usage","text":"","category":"section"},{"location":"integrators/euler/","page":"Euler","title":"Euler","text":"The desired integration method used for continuous-time dynamics is passed to the simulate function as a keyword argument.","category":"page"},{"location":"integrators/euler/","page":"Euler","title":"Euler","text":"using SimpleSim\n\n# my_model = ...\n\nout = simulate(my_model, T = T_end, integrator = Euler)","category":"page"},{"location":"integrators/euler/#Mathematical-Background","page":"Euler","title":"Mathematical Background","text":"","category":"section"},{"location":"integrators/euler/","page":"Euler","title":"Euler","text":"The state x^+ estimating the true state at time t+Delta t is determined by simple integration of the current derivative dotx(t) computed using the dynamics function f(x(t) u(t) p t).","category":"page"},{"location":"integrators/euler/","page":"Euler","title":"Euler","text":"x^+ = x + Delta t cdot f(x u(t) p t)","category":"page"},{"location":"integrators/euler/","page":"Euler","title":"Euler","text":"This method is also referred to as forward Euler method and is the most basic explicit method for solving initial value problems.","category":"page"},{"location":"integrators/euler/","page":"Euler","title":"Euler","text":"You can read more about this topic on Wikipedia or any text book on the topic, many of which are available on the internet.","category":"page"},{"location":"integrators/euler/#Performance","page":"Euler","title":"Performance","text":"","category":"section"},{"location":"integrators/euler/","page":"Euler","title":"Euler","text":"For each iteration, the dynamics function f is only called once and the state update itself is computationally very inexpensive.","category":"page"},{"location":"manual/zero_crossing/#Zero-Crossing-Detection","page":"Zero-Crossing Detection","title":"Zero-Crossing Detection","text":"","category":"section"},{"location":"manual/zero_crossing/","page":"Zero-Crossing Detection","title":"Zero-Crossing Detection","text":"The zero-crossing detection feature allows for building models that have discontinuous dynamics. An example for a dynamical system where this feature is used would be a ball bouncing up and down on a hard surface.","category":"page"},{"location":"manual/zero_crossing/#Theory","page":"Zero-Crossing Detection","title":"Theory","text":"","category":"section"},{"location":"manual/zero_crossing/","page":"Zero-Crossing Detection","title":"Zero-Crossing Detection","text":"The goal of a zero-crossing detector is to solve the following equation","category":"page"},{"location":"manual/zero_crossing/","page":"Zero-Crossing Detection","title":"Zero-Crossing Detection","text":"0 = z(x(t) p t)","category":"page"},{"location":"manual/zero_crossing/","page":"Zero-Crossing Detection","title":"Zero-Crossing Detection","text":"for x(t) and t.","category":"page"},{"location":"manual/zero_crossing/","page":"Zero-Crossing Detection","title":"Zero-Crossing Detection","text":"In simulation, this is done by checking for a change of sign in z.","category":"page"},{"location":"manual/zero_crossing/","page":"Zero-Crossing Detection","title":"Zero-Crossing Detection","text":"If","category":"page"},{"location":"manual/zero_crossing/","page":"Zero-Crossing Detection","title":"Zero-Crossing Detection","text":"z(x(t) p t)  0\nz(x(t + T) p t + T)  0","category":"page"},{"location":"manual/zero_crossing/","page":"Zero-Crossing Detection","title":"Zero-Crossing Detection","text":"then a zero-crossing has happened. In that case, a bisection algorithm is applied to find T^*, such that","category":"page"},{"location":"manual/zero_crossing/","page":"Zero-Crossing Detection","title":"Zero-Crossing Detection","text":"lvert z(x(t + T^*) p t + T^*)rvert  varepsilon","category":"page"},{"location":"manual/zero_crossing/","page":"Zero-Crossing Detection","title":"Zero-Crossing Detection","text":"where varepsilon is a small tolerance.","category":"page"},{"location":"manual/zero_crossing/#Implementation","page":"Zero-Crossing Detection","title":"Implementation","text":"","category":"section"},{"location":"manual/zero_crossing/","page":"Zero-Crossing Detection","title":"Zero-Crossing Detection","text":"SimpleSim.jl supports the optional fields zc and zc_exec for continuous-time models that are used to implement the zero-crossing detection feature.","category":"page"},{"location":"manual/zero_crossing/","page":"Zero-Crossing Detection","title":"Zero-Crossing Detection","text":"zc tells us when the zero-crossing is happening\nzc_exec tells us what to do, once a zero-crossing is found","category":"page"},{"location":"manual/zero_crossing/#zc-function","page":"Zero-Crossing Detection","title":"zc function","text":"","category":"section"},{"location":"manual/zero_crossing/","page":"Zero-Crossing Detection","title":"Zero-Crossing Detection","text":"The function passed to zc takes the current state, the model parameters and the current time as an input and returns a Number. This number represents the quantity that is critical for a zero-crossing.","category":"page"},{"location":"manual/zero_crossing/","page":"Zero-Crossing Detection","title":"Zero-Crossing Detection","text":"function zc_my_model(x, p, t)\n    my_zc_indicator = # ...\n    return my_zc_indicator\nend","category":"page"},{"location":"manual/zero_crossing/","page":"Zero-Crossing Detection","title":"Zero-Crossing Detection","text":"If the number returned by zc changes its sign, the simulation engine will try to figure out when exactly the zero-crossing has happened. In order to do so, a bisection algorithm is applied to find the right simulation step size, so that the next simulation step occurs right at the time of the zero-crossing.","category":"page"},{"location":"manual/zero_crossing/#zc_exec-function","page":"Zero-Crossing Detection","title":"zc_exec function","text":"","category":"section"},{"location":"manual/zero_crossing/","page":"Zero-Crossing Detection","title":"Zero-Crossing Detection","text":"This function tells the simulation engine what to do, once it has figured out when a zero-crossing is happening (as defined by zc).","category":"page"},{"location":"manual/zero_crossing/","page":"Zero-Crossing Detection","title":"Zero-Crossing Detection","text":"The zc_exec works similar to a discrete-time state update. When a zero-crossing is happening, it is called exactly once and should return a new, post-zero-crossing state of the system.","category":"page"},{"location":"manual/zero_crossing/","page":"Zero-Crossing Detection","title":"Zero-Crossing Detection","text":"function zc_exec_my_model(x, u, p, t)\n    my_new_state = # ...\n    return my_new_state\nend","category":"page"},{"location":"manual/zero_crossing/","page":"Zero-Crossing Detection","title":"Zero-Crossing Detection","text":"The new state should be constructed in a way that resolves the zero-crossing. Otherwise, the simulation can get stuck in a loop.","category":"page"},{"location":"manual/zero_crossing/","page":"Zero-Crossing Detection","title":"Zero-Crossing Detection","text":"In summary, a model with zero-crossing detection could look something like this.","category":"page"},{"location":"manual/zero_crossing/","page":"Zero-Crossing Detection","title":"Zero-Crossing Detection","text":"my_ct_model = (\n    p = nothing,\n    fc = fc_my_model,\n    gc = gc_my_model,\n    zc = zc_my_model,\n    zc_exec = zc_exec_my_model,\n    xc0 = my_initial_state,\n    uc0 = my_initial_input,\n)","category":"page"},{"location":"manual/zero_crossing/","page":"Zero-Crossing Detection","title":"Zero-Crossing Detection","text":"Since varying the simulation step size is not allowed for discrete-time systems, zero-crossing detection is only supported for continuous-time systems.","category":"page"},{"location":"integrators/heun/#Heun's-Method-/-Explicit-Trapezoidal-Integration-/-Heun","page":"Heun","title":"Heun's Method / Explicit Trapezoidal Integration / Heun","text":"","category":"section"},{"location":"integrators/heun/#Usage","page":"Heun","title":"Usage","text":"","category":"section"},{"location":"integrators/heun/","page":"Heun","title":"Heun","text":"The desired integration method used for continuous-time dynamics is passed to the simulate function as a keyword argument.","category":"page"},{"location":"integrators/heun/","page":"Heun","title":"Heun","text":"using SimpleSim\n\n# my_model = ...\n\nout = simulate(my_model, T = T_end, integrator = Heun)","category":"page"},{"location":"integrators/heun/#Mathematical-Background","page":"Heun","title":"Mathematical Background","text":"","category":"section"},{"location":"integrators/heun/","page":"Heun","title":"Heun","text":"Heun's method, also known as improved Euler's method or explicit trapezoidal rule is a two-stage method.","category":"page"},{"location":"integrators/heun/","page":"Heun","title":"Heun","text":"First, an intermediate estimate of the next state tildex^+ is computed using Euler's method","category":"page"},{"location":"integrators/heun/","page":"Heun","title":"Heun","text":"tildex^+ = x + Delta tcdot f(x u(t) p t)","category":"page"},{"location":"integrators/heun/","page":"Heun","title":"Heun","text":"The final estimate x^+ is then computed using a weighted average of the current derivative and the expected derivative at the next Euler step.","category":"page"},{"location":"integrators/heun/","page":"Heun","title":"Heun","text":"x^+ = x + fracDelta t2 (f(x u(t) p t) + f(tildex^+ u(t + Delta t) p t + Delta t))","category":"page"},{"location":"integrators/heun/","page":"Heun","title":"Heun","text":"You can read more about this topic on Wikipedia.","category":"page"},{"location":"integrators/heun/#Performance","page":"Heun","title":"Performance","text":"","category":"section"},{"location":"integrators/heun/","page":"Heun","title":"Heun","text":"The two-step process used in Heun's method results in two calls of the dynamics function f being made. Therefore, the computational effort is about twice as large compared to Euler's method. However, in most cases, Heun's method is still very fast.","category":"page"},{"location":"integrators/heun/","page":"Heun","title":"Heun","text":"Compared to Euler's method, the accumulation of errors has a significantly lower effect when using Heun's method yielding much better results.","category":"page"},{"location":"examples/minimal_example/#Minimal-Example","page":"Minimal Example","title":"Minimal Example","text":"","category":"section"},{"location":"examples/minimal_example/","page":"Minimal Example","title":"Minimal Example","text":"This example simulates a falling object. Its physics are governed by what probably is the simplest example of an ordinary differential equation.","category":"page"},{"location":"examples/minimal_example/","page":"Minimal Example","title":"Minimal Example","text":"ddotx = -g","category":"page"},{"location":"examples/minimal_example/","page":"Minimal Example","title":"Minimal Example","text":"We implement the object by defining a system of first-order differential equations","category":"page"},{"location":"examples/minimal_example/","page":"Minimal Example","title":"Minimal Example","text":"dotz_1 = z_2\ndotz_2 = -g","category":"page"},{"location":"examples/minimal_example/","page":"Minimal Example","title":"Minimal Example","text":"and implement the system in a fc function as follows","category":"page"},{"location":"examples/minimal_example/","page":"Minimal Example","title":"Minimal Example","text":"fc_falling_object = (z, u, p, t) -> [z[2], -p.g]","category":"page"},{"location":"examples/minimal_example/","page":"Minimal Example","title":"Minimal Example","text":"The gravitational constant is stored in the model as a parameter. The output of our system will simply be the current position of the object, i. e. z_1.","category":"page"},{"location":"examples/minimal_example/","page":"Minimal Example","title":"Minimal Example","text":"gc_falling_object = (z, u, p, t) -> z[1]","category":"page"},{"location":"examples/minimal_example/","page":"Minimal Example","title":"Minimal Example","text":"Now, the whole model can be written as","category":"page"},{"location":"examples/minimal_example/","page":"Minimal Example","title":"Minimal Example","text":"falling_object = (\n    p = (g = 9.81,),\n    fc = fc_falling_object,\n    gc = gc_falling_object,\n)","category":"page"},{"location":"examples/minimal_example/","page":"Minimal Example","title":"Minimal Example","text":"Which can be simulated as","category":"page"},{"location":"examples/minimal_example/","page":"Minimal Example","title":"Minimal Example","text":"data = simulate(falling_object, T = 3 // 1, xc0 = [0, 0])","category":"page"},{"location":"examples/minimal_example/","page":"Minimal Example","title":"Minimal Example","text":"Done! This is the most minimal example I could think of, essentially being made up of four lines of code!","category":"page"},{"location":"examples/minimal_example/","page":"Minimal Example","title":"Minimal Example","text":"The position of the object (double integral of -g) can now be accessed using data.ycs.","category":"page"},{"location":"manual/nested_sims/#Nested-Models","page":"Nested Models","title":"Nested Models","text":"","category":"section"},{"location":"manual/nested_sims/","page":"Nested Models","title":"Nested Models","text":"One of SimpleSim.jl's most powerful feature is the ability to structure models in hierarchies. In other words, every model in a simulation can have an arbitrary number of submodels.","category":"page"},{"location":"manual/nested_sims/","page":"Nested Models","title":"Nested Models","text":"This enables you to use SimpleSim.jl in a similar way to how you would draw a control block diagram.","category":"page"},{"location":"manual/nested_sims/","page":"Nested Models","title":"Nested Models","text":"For example, the closed-loop system consisting of a controller and a plant could be implemented as three systems:","category":"page"},{"location":"manual/nested_sims/","page":"Nested Models","title":"Nested Models","text":"the controller\nthe plant\na feedback system","category":"page"},{"location":"manual/nested_sims/","page":"Nested Models","title":"Nested Models","text":"The controller and the plant would then be subsystems of the \"feedback sytem\". The feedback system takes care of passing the current output of the plant to the controller and calling the plant with the current control input.","category":"page"},{"location":"manual/nested_sims/#Creating-Submodels","page":"Nested Models","title":"Creating Submodels","text":"","category":"section"},{"location":"manual/nested_sims/","page":"Nested Models","title":"Nested Models","text":"SimpleSim.jl accepts three types of collections to serve as a list of submodels:","category":"page"},{"location":"manual/nested_sims/","page":"Nested Models","title":"Nested Models","text":"Vector\nTuple\nNamedTuple","category":"page"},{"location":"manual/nested_sims/","page":"Nested Models","title":"Nested Models","text":"Given three submodels model_1, model_2 and model_3 created as described in the chapters about continuous-time and discrete-time models, the creation of the submodels structure is shown below.","category":"page"},{"location":"manual/nested_sims/","page":"Nested Models","title":"Nested Models","text":"As a Vector:","category":"page"},{"location":"manual/nested_sims/","page":"Nested Models","title":"Nested Models","text":"my_submodels = [model_1, model_2, model_3]","category":"page"},{"location":"manual/nested_sims/","page":"Nested Models","title":"Nested Models","text":"As a Tuple:","category":"page"},{"location":"manual/nested_sims/","page":"Nested Models","title":"Nested Models","text":"my_submodels = (model_1, model_2, model_3)","category":"page"},{"location":"manual/nested_sims/","page":"Nested Models","title":"Nested Models","text":"As a NamedTuple:","category":"page"},{"location":"manual/nested_sims/","page":"Nested Models","title":"Nested Models","text":"my_submodels = (\n    m_1 = model_1,\n    m_2 = model_2,\n    m_3 = model_3\n)","category":"page"},{"location":"manual/nested_sims/","page":"Nested Models","title":"Nested Models","text":"Any of the above can be passed to the parent model as follows.","category":"page"},{"location":"manual/nested_sims/","page":"Nested Models","title":"Nested Models","text":"my_ct_model = (\n    p = nothing,\n    fc = fc_my_model,\n    gc = gc_my_model,\n    xc0 = my_initial_state,\n    uc0 = my_initial_input,\n    models = my_submodels,\n)","category":"page"},{"location":"manual/nested_sims/#Calling-Submodels","page":"Nested Models","title":"Calling Submodels","text":"","category":"section"},{"location":"manual/nested_sims/","page":"Nested Models","title":"Nested Models","text":"Only the top-level passed to the simulate function is actively called by SimpleSim.jl. Submodels must be called by their respective parent model.","category":"page"},{"location":"manual/nested_sims/","page":"Nested Models","title":"Nested Models","text":"This is done using the @call! macro and can only be done from within the gc and gd functions. Calls from inside fc or fd are not allowed for technical reasons.","category":"page"},{"location":"manual/nested_sims/","page":"Nested Models","title":"Nested Models","text":"An example of how to call a submodel is given below.","category":"page"},{"location":"manual/nested_sims/","page":"Nested Models","title":"Nested Models","text":"function gc_my_model(x, u, p, t; models)\n    my_submodel_input = # ...\n\n    # if `models` is a Vector or Tuple\n    y = @call! models[1] my_submodel_input\n\n    # if `models` is a NamedTuple\n    y = @call! models.m_1 my_submodel_input\nend","category":"page"},{"location":"manual/nested_sims/","page":"Nested Models","title":"Nested Models","text":"After calling (and therefore updating) a submodel you can do whatever you need to do with its output. Note that SimpleSim.jl takes care of timing issues. Submodels are only updated if they are due. This is of course only relevant for discrete-time systems.","category":"page"},{"location":"manual/nested_sims/","page":"Nested Models","title":"Nested Models","text":"If you need to access the output of a submodel from inside a fc function, use the @out macro. It returns the current output of a submodel without updating it.","category":"page"},{"location":"manual/nested_sims/","page":"Nested Models","title":"Nested Models","text":"function fc_my_model(x, u, p, t; models)\n    # if `models` is a Vector or Tuple\n    y = @out models[1]\n\n    # if `models` is a NamedTuple\n    y = @out models.m_1\nend","category":"page"},{"location":"manual/nested_sims/","page":"Nested Models","title":"Nested Models","text":"Several illustrative examples of nested simulations are given in the examples section.","category":"page"},{"location":"manual/output/#Simulation-Output","page":"Simulation Output","title":"Simulation Output","text":"","category":"section"},{"location":"manual/output/","page":"Simulation Output","title":"Simulation Output","text":"If you run a simulation","category":"page"},{"location":"manual/output/","page":"Simulation Output","title":"Simulation Output","text":"data = simulate(my_model, T = T)","category":"page"},{"location":"manual/output/","page":"Simulation Output","title":"Simulation Output","text":"the object data will contain all relevant simulation output.","category":"page"},{"location":"manual/output/","page":"Simulation Output","title":"Simulation Output","text":"The output object mimics the structure of the respective model and can contain the following fields","category":"page"},{"location":"manual/output/","page":"Simulation Output","title":"Simulation Output","text":"model_id\nΔt\ntcs\nxcs\nycs\ntds\nxds\nyds\nwds\nmodels","category":"page"},{"location":"manual/output/","page":"Simulation Output","title":"Simulation Output","text":"The first two fields contain information about the model itself and should be self explanatory. The fields tcs, xcs and ycs contain vectors or matrices that represent the simulation output generated by the fc and gc functions over the course of the simulation. The same is true for the discrete-time system outputs tds, xds, yds and wds.","category":"page"},{"location":"manual/output/","page":"Simulation Output","title":"Simulation Output","text":"Output of submodels can be accessed via the models field. For example, if the top-level model has a continuous-time submodel called my_submodel, then its output can be accessed via data.models.my_submodel.ycs.","category":"page"},{"location":"manual/random_vars/#Random-Variables","page":"Random Variables","title":"Random Variables","text":"","category":"section"},{"location":"manual/random_vars/","page":"Random Variables","title":"Random Variables","text":"For discrete-time systems, SimpleSim.jl can handle random variables for you.","category":"page"},{"location":"manual/random_vars/","page":"Random Variables","title":"Random Variables","text":"If you want to use this feature, define a random draw function, and include it in your discrete-time model under the wd name.","category":"page"},{"location":"manual/random_vars/","page":"Random Variables","title":"Random Variables","text":"function my_random_wd(x, u, p, t, rng)\n    # ...\n    return my_random_draw\nend\n\nmy_system = (\n    p = # ...\n    Δt = # ...\n    xd0 = # ...\n    ud0 = # ...\n    fd = # ...\n    gd = # ...\n    wd = my_random_wd,\n)","category":"page"},{"location":"manual/random_vars/","page":"Random Variables","title":"Random Variables","text":"The function wd_random_draws takes in the usual argument and a random number generator rng. The random number generator can be used in the random draw function to generate any number of random draws using available techniques, e. g. the Distributions package.","category":"page"},{"location":"manual/random_vars/","page":"Random Variables","title":"Random Variables","text":"Then, SimpleSim.jl passes the random draw to the fd and gd functions in the keyword argument w.","category":"page"},{"location":"manual/random_vars/","page":"Random Variables","title":"Random Variables","text":"function my_fd(x, u, p, t; w)\n    # ...\nend\n\nfunction my_gd(x, u, p, t; w)\n    # ...\nend","category":"page"},{"location":"manual/random_vars/","page":"Random Variables","title":"Random Variables","text":"See the examples section for a \"random walk\" example.","category":"page"},{"location":"examples/random_walk/#Random-Walk","page":"Random Walk","title":"Random Walk","text":"","category":"section"},{"location":"examples/random_walk/","page":"Random Walk","title":"Random Walk","text":"This example implements a classical example from mathematics, where successive random steps are taken based on a given probability density function.","category":"page"},{"location":"examples/random_walk/#Mathematics","page":"Random Walk","title":"Mathematics","text":"","category":"section"},{"location":"examples/random_walk/","page":"Random Walk","title":"Random Walk","text":"In this example, a 2D walk is considered in which the \"walker\" can take a step forward, backward, left and right with certain probability.","category":"page"},{"location":"examples/random_walk/","page":"Random Walk","title":"Random Walk","text":"The current position of the walker is denoted as x. On the xy-plane, \"forward\" is considered to be a step \"up\", i.e. in positive y-direction, and all other directions are chosen accordingly. Then, the position of the walker after taking a step, can be determined as follows","category":"page"},{"location":"examples/random_walk/","page":"Random Walk","title":"Random Walk","text":"x_+ = x + e","category":"page"},{"location":"examples/random_walk/","page":"Random Walk","title":"Random Walk","text":"where e is drawn from the following discrete distribution.","category":"page"},{"location":"examples/random_walk/","page":"Random Walk","title":"Random Walk","text":"E(X) = begincases\np_f  textif  X = 0 1^T\np_b  textif  X = 0 -1^T\np_l  textif  X = -1 0^T\np_r  textif  X = 1 0^T\nendcases","category":"page"},{"location":"examples/random_walk/","page":"Random Walk","title":"Random Walk","text":"Note that p_f + p_b + p_l + p_r = 1 and that the walker cannot remain at its current position, i. e. E(0 0) = 0.","category":"page"},{"location":"examples/random_walk/#Implementation","page":"Random Walk","title":"Implementation","text":"","category":"section"},{"location":"examples/random_walk/","page":"Random Walk","title":"Random Walk","text":"The random walk is implemented as a discrete-time dynamical system with a two-dimensional state.","category":"page"},{"location":"examples/random_walk/#Setting-up-the-Model","page":"Random Walk","title":"Setting up the Model","text":"","category":"section"},{"location":"examples/random_walk/","page":"Random Walk","title":"Random Walk","text":"The dynamics of the system are straightforward to implement.","category":"page"},{"location":"examples/random_walk/","page":"Random Walk","title":"Random Walk","text":"function fd_random_walk(x, u, p, t; w)\n    return x + w\nend\n\ngd_random_walk = (x, u, p, t; w) -> x","category":"page"},{"location":"examples/random_walk/","page":"Random Walk","title":"Random Walk","text":"The probabilities p_i for the 4 state transitions are stored in the parameters p.","category":"page"},{"location":"examples/random_walk/","page":"Random Walk","title":"Random Walk","text":"params = (\n    p_f = 0.25,\n    p_b = 0.25,\n    p_l = 0.25,\n    p_r = 0.25,\n)","category":"page"},{"location":"examples/random_walk/","page":"Random Walk","title":"Random Walk","text":"The random draw function itself can be implemented using the rand() function. It generates a random number between zero and one. The interval 0 1 is then partitioned into subintervals depending on the probabilities p_i.","category":"page"},{"location":"examples/random_walk/","page":"Random Walk","title":"Random Walk","text":"function wd_random_walk(x, u, p, t, rng)\n    r = rand(rng)\n    if r < p.p_f\n        return [0, 1]\n    elseif r < p.p_f + p.p_b\n        return [0, -1]\n    elseif r < p.p_f + p.p_b + p_l\n        return [-1, 0]\n    else\n        return[1, 0]\n    end\nend","category":"page"},{"location":"examples/random_walk/","page":"Random Walk","title":"Random Walk","text":"The model then can be defined as follows","category":"page"},{"location":"examples/random_walk/","page":"Random Walk","title":"Random Walk","text":"seed = 1234\nrandom_walk_model = (\n    p = params,\n    fd = fd_random_walk,\n    gd = gd_random_walk,\n    wd = wd_random_walk,\n    wd_seed = seed,\n    xd0 = [0, 0],\n    Δt = 1 // 1,\n)","category":"page"},{"location":"examples/random_walk/","page":"Random Walk","title":"Random Walk","text":"Note how the seed is passed to the model, not the simulation. Giving each model its own seed, ensures reproducibility of results as long as the wd function of the model does not change.","category":"page"},{"location":"examples/random_walk/#Running-the-Simulation","page":"Random Walk","title":"Running the Simulation","text":"","category":"section"},{"location":"examples/random_walk/","page":"Random Walk","title":"Random Walk","text":"The random walk model is simulated like any other model","category":"page"},{"location":"examples/random_walk/","page":"Random Walk","title":"Random Walk","text":"N = 10\ndata = simulate(random_walk_model, T = N // 1)","category":"page"},{"location":"examples/random_walk/","page":"Random Walk","title":"Random Walk","text":"where N is the number of steps taken by the walker.","category":"page"},{"location":"examples/random_walk/#Results","page":"Random Walk","title":"Results","text":"","category":"section"},{"location":"examples/random_walk/","page":"Random Walk","title":"Random Walk","text":"The following animations show a random walk for N = 10 and N = 1000.","category":"page"},{"location":"examples/random_walk/","page":"Random Walk","title":"Random Walk","text":"<img src=\"../../assets/random_walk_animation_10.gif\" style=\"width: 50%;\" align=\"left\">\n<img src=\"../../assets/random_walk_animation_1000.gif\" style=\"width: 50%;\" align=\"right\"><br><br>","category":"page"},{"location":"examples/random_walk/#Switching-to-a-different-RNG","page":"Random Walk","title":"Switching to a different RNG","text":"","category":"section"},{"location":"examples/random_walk/","page":"Random Walk","title":"Random Walk","text":"If you want to use a different random number generator than MersenneTwister, you can pass it to SimpleSim.jl using the options keyword argument of simulate.","category":"page"},{"location":"examples/random_walk/","page":"Random Walk","title":"Random Walk","text":"using Random\nN = 10\ndata = simulate(random_walk_model,\n    T = N // 1,\n    options = (\n        base_rng = Xoshiro,\n    )\n)","category":"page"},{"location":"manual/misc/#Miscellanoues-Functionalities","page":"Miscellaneous","title":"Miscellanoues Functionalities","text":"","category":"section"},{"location":"manual/misc/#Analyzing-the-Model-Structure","page":"Miscellaneous","title":"Analyzing the Model Structure","text":"","category":"section"},{"location":"manual/misc/","page":"Miscellaneous","title":"Miscellaneous","text":"print_model_tree(model; io = stdout)","category":"page"},{"location":"manual/misc/#SimpleSim.print_model_tree-Tuple{Any}","page":"Miscellaneous","title":"SimpleSim.print_model_tree","text":"print_model_tree(model; io = stdout)\n\nPrints a tree of the given model similar to a folder tree printed by the Linux tree command.\n\nAn example for a feedback-controlled inverted pendulum could look like this\n\njulia> print_model_tree(my_model)\n└─1 (TypeCT): top-level model / FeedbackSystem\n  ├─2 (TypeCT): .inverted_pendulum / NamedTuple\n  └─3 (TypeCT): .controller / NamedTuple\n\nFirst, the model_id is indicated, following the type (TypeCT, TypeDT or TypeHybrid). Then follows the name of each model in the super model. This is either its field name in the NamedTuple passed as models or the index in the case of vectors or tuples. Finally, after the slash, the type of each model is indicated. This should either be the name of a struct type, or NamedTuple.\n\nYou can also pass your own IO stream to print_model_tree as follows\n\nprint_model_tree(my_buffer, model)\n\n\n\n\n\n","category":"method"},{"location":"manual/ct_sims/#Continuous-Time-Models","page":"Continuous-Time Models","title":"Continuous-Time Models","text":"","category":"section"},{"location":"manual/ct_sims/","page":"Continuous-Time Models","title":"Continuous-Time Models","text":"We assume every continuous-time model to consist of a dynamics model f and a measurement model g.","category":"page"},{"location":"manual/ct_sims/","page":"Continuous-Time Models","title":"Continuous-Time Models","text":"dotx(t) = f(x(t) u(t) p t)\ny(t) = g(x(t) u(t) p t)","category":"page"},{"location":"manual/ct_sims/","page":"Continuous-Time Models","title":"Continuous-Time Models","text":"The dynamics model is given by a first-order ordinary differential equation. The measurement model is given by a simple algebraic function.","category":"page"},{"location":"manual/ct_sims/#Dynamics-Model","page":"Continuous-Time Models","title":"Dynamics Model","text":"","category":"section"},{"location":"manual/ct_sims/","page":"Continuous-Time Models","title":"Continuous-Time Models","text":"The SimpleSim.jl equivalent of the first-order ordinary differential equation","category":"page"},{"location":"manual/ct_sims/","page":"Continuous-Time Models","title":"Continuous-Time Models","text":"dotx(t) = f(x(t) u(t) p t)","category":"page"},{"location":"manual/ct_sims/","page":"Continuous-Time Models","title":"Continuous-Time Models","text":"is to define a function that returns the current derivative of x as an AbstractVector.","category":"page"},{"location":"manual/ct_sims/","page":"Continuous-Time Models","title":"Continuous-Time Models","text":"function fc_my_model(x, u, p, t)\n    my_x_derivative = # ...\n    return my_x_derivative\nend","category":"page"},{"location":"manual/ct_sims/","page":"Continuous-Time Models","title":"Continuous-Time Models","text":"Implicit differential equations 0 = F(dotx x u p t) are not supported (yet...).","category":"page"},{"location":"manual/ct_sims/#Measurement-Model","page":"Continuous-Time Models","title":"Measurement Model","text":"","category":"section"},{"location":"manual/ct_sims/","page":"Continuous-Time Models","title":"Continuous-Time Models","text":"The measurement model","category":"page"},{"location":"manual/ct_sims/","page":"Continuous-Time Models","title":"Continuous-Time Models","text":"y(t) = g(x(t) u(t) p t)","category":"page"},{"location":"manual/ct_sims/","page":"Continuous-Time Models","title":"Continuous-Time Models","text":"is also implemented as a simple Julia function that returns the current output y(t) given the current state x(t), input u(t) and time t, as well as the parameters p. The output y should also be returned as an AbstractVector.","category":"page"},{"location":"manual/ct_sims/","page":"Continuous-Time Models","title":"Continuous-Time Models","text":"function gc_my_model(x, u, p, t)\n    my_output = # ...\n    return my_output\nend","category":"page"},{"location":"manual/ct_sims/#Model-Creation","page":"Continuous-Time Models","title":"Model Creation","text":"","category":"section"},{"location":"manual/ct_sims/","page":"Continuous-Time Models","title":"Continuous-Time Models","text":"Every SimpleSim.jl model has to be a data structure with named fields. So, you can use a custom struct to define your models or simply use a NamedTuple. Structs may have some advantages when it comes to debugging your code, however, for simple examples, NamedTuples are more than sufficient.","category":"page"},{"location":"manual/ct_sims/","page":"Continuous-Time Models","title":"Continuous-Time Models","text":"my_ct_model = (\n    p = nothing,\n    fc = fc_my_model,\n    gc = gc_my_model,\n    xc0 = my_initial_state,\n    uc0 = my_initial_input,\n)","category":"page"},{"location":"manual/ct_sims/","page":"Continuous-Time Models","title":"Continuous-Time Models","text":"Mandatory fields for continuous-time models:","category":"page"},{"location":"manual/ct_sims/","page":"Continuous-Time Models","title":"Continuous-Time Models","text":"p, set this to nothing if no parameters are needed\nfc, pass your dynamics function, returning the right-hand side of the ODE\ngc, pass your measurement function","category":"page"},{"location":"manual/ct_sims/","page":"Continuous-Time Models","title":"Continuous-Time Models","text":"Optional fields for continuous-time models:","category":"page"},{"location":"manual/ct_sims/","page":"Continuous-Time Models","title":"Continuous-Time Models","text":"xc0, the initial state of the system, nothing by default. Can be overriden by an initial state directly passed to the simulate function.\nuc0, the initial input of the system, nothing by default.\nzc, function that returns a scalar and will be watched by SimpleSim.jl to detect zero-crossings.\nzc_exec, function that returns a post-zero-crossing state","category":"page"},{"location":"manual/dt_sims/#Discrete-Time-Models","page":"Discrete-Time & Hybrid Models","title":"Discrete-Time Models","text":"","category":"section"},{"location":"manual/dt_sims/","page":"Discrete-Time & Hybrid Models","title":"Discrete-Time & Hybrid Models","text":"Discrete-time models are defined by a \"step\" function, that returns the next state, based on the current state of the system and a measurement function.","category":"page"},{"location":"manual/dt_sims/","page":"Discrete-Time & Hybrid Models","title":"Discrete-Time & Hybrid Models","text":"x_k+1 = f(x_k u_k p t)\ny_k = g(x_k u_k p t)","category":"page"},{"location":"manual/dt_sims/","page":"Discrete-Time & Hybrid Models","title":"Discrete-Time & Hybrid Models","text":"Both f and g are assumed to be explicit, algebraic functions. Implicit definitions of x_k+1 and y_k are not supported.","category":"page"},{"location":"manual/dt_sims/#Dynamics-Model","page":"Discrete-Time & Hybrid Models","title":"Dynamics Model","text":"","category":"section"},{"location":"manual/dt_sims/","page":"Discrete-Time & Hybrid Models","title":"Discrete-Time & Hybrid Models","text":"The discrete-time dynamics","category":"page"},{"location":"manual/dt_sims/","page":"Discrete-Time & Hybrid Models","title":"Discrete-Time & Hybrid Models","text":"x_k+1 = f(x_k u_k p t)","category":"page"},{"location":"manual/dt_sims/","page":"Discrete-Time & Hybrid Models","title":"Discrete-Time & Hybrid Models","text":"are modeled in SimpleSim.jl using a simple Julia function that returns x_k+1 as an AbstractVector.","category":"page"},{"location":"manual/dt_sims/","page":"Discrete-Time & Hybrid Models","title":"Discrete-Time & Hybrid Models","text":"function fd_my_model(x, u, p, t)\n    my_next_x = # ...\n    return my_next_x\nend","category":"page"},{"location":"manual/dt_sims/","page":"Discrete-Time & Hybrid Models","title":"Discrete-Time & Hybrid Models","text":"Note, that while working with integer time-steps k, the functions f and g still accept the actual time t as an input. This is more practical for most applications. If you want to work with integer time steps k instead, make sure to use a sampling time of 1 // 1 and convert the time t to an integer inside your functions f and g.","category":"page"},{"location":"manual/dt_sims/#Measurement-Model","page":"Discrete-Time & Hybrid Models","title":"Measurement Model","text":"","category":"section"},{"location":"manual/dt_sims/","page":"Discrete-Time & Hybrid Models","title":"Discrete-Time & Hybrid Models","text":"The measurement model","category":"page"},{"location":"manual/dt_sims/","page":"Discrete-Time & Hybrid Models","title":"Discrete-Time & Hybrid Models","text":"y_k = g(x_k u_k p t)","category":"page"},{"location":"manual/dt_sims/","page":"Discrete-Time & Hybrid Models","title":"Discrete-Time & Hybrid Models","text":"is also given by a simple Julia function","category":"page"},{"location":"manual/dt_sims/","page":"Discrete-Time & Hybrid Models","title":"Discrete-Time & Hybrid Models","text":"function gd_my_model(x, u, p, t)\n    my_output = # ...\n    return my_output\nend","category":"page"},{"location":"manual/dt_sims/","page":"Discrete-Time & Hybrid Models","title":"Discrete-Time & Hybrid Models","text":"(Pretty straighforward, right?)","category":"page"},{"location":"manual/dt_sims/#Model-Creation","page":"Discrete-Time & Hybrid Models","title":"Model Creation","text":"","category":"section"},{"location":"manual/dt_sims/","page":"Discrete-Time & Hybrid Models","title":"Discrete-Time & Hybrid Models","text":"Similar to continuous-time models, SimpleSim.jl supports all types of models that have named fields. So you can either define your own struct for each type of model, or simply use a NamedTuple.","category":"page"},{"location":"manual/dt_sims/","page":"Discrete-Time & Hybrid Models","title":"Discrete-Time & Hybrid Models","text":"my_dt_model = (\n    p = nothing,\n    fd = fd_my_model,\n    gd = gd_my_model,\n    Δt = Δt_my_model,\n    xd0 = my_initial_state,\n    ud0 = my_initial_input,\n)","category":"page"},{"location":"manual/dt_sims/","page":"Discrete-Time & Hybrid Models","title":"Discrete-Time & Hybrid Models","text":"Mandatory fields for discrete-time models:","category":"page"},{"location":"manual/dt_sims/","page":"Discrete-Time & Hybrid Models","title":"Discrete-Time & Hybrid Models","text":"p, set this to nothing if no parameters are needed\nfd, pass your dynamics function returning the next state\ngd, pass your measurement function\nΔt, the desired sampling time of the discrete-time model, use 1 // 1 for integer time steps k.","category":"page"},{"location":"manual/dt_sims/","page":"Discrete-Time & Hybrid Models","title":"Discrete-Time & Hybrid Models","text":"Optional fields for discrete-time models:","category":"page"},{"location":"manual/dt_sims/","page":"Discrete-Time & Hybrid Models","title":"Discrete-Time & Hybrid Models","text":"xd0, the initial state of the system, nothing by default. Can be overriden by initial state directly passed to the simulate function.\nud0, the initial input of the system, nothing by default.\nwd, function (x, u, p, t, rng) -> ... that returns a random draw. The random draw will be passed as a keyword argument w to fd and gd.\nwd_seed, the seed used for this model's random number generator","category":"page"},{"location":"manual/dt_sims/#Hybrid-Models","page":"Discrete-Time & Hybrid Models","title":"Hybrid Models","text":"","category":"section"},{"location":"manual/dt_sims/","page":"Discrete-Time & Hybrid Models","title":"Discrete-Time & Hybrid Models","text":"Models can have both continuous-time and discrete-time dynamics. These kind of models are considered HybridModels by SimpleSim.jl and they work very similar to continuous-time or discrete-time models.","category":"page"},{"location":"manual/dt_sims/","page":"Discrete-Time & Hybrid Models","title":"Discrete-Time & Hybrid Models","text":"Note, that for hybrid models, the mandatory fields for both continuous-time and discrete-time models must be given.","category":"page"},{"location":"manual/dt_sims/","page":"Discrete-Time & Hybrid Models","title":"Discrete-Time & Hybrid Models","text":"See @call_ct!/@call_dt!, @out_ct/@out_dt, and @state_ct/@state_dt for some comments about how do avoid ambiguity when working with hybrid models.","category":"page"},{"location":"integrators/rk4/#4th-Order-Runge-Kutta-Method-/-RK4","page":"4th Order Runge-Kutta","title":"4th Order Runge-Kutta Method / RK4","text":"","category":"section"},{"location":"integrators/rk4/#Usage","page":"4th Order Runge-Kutta","title":"Usage","text":"","category":"section"},{"location":"integrators/rk4/","page":"4th Order Runge-Kutta","title":"4th Order Runge-Kutta","text":"The desired integration method used for continuous-time dynamics is passed to the simulate function as a keyword argument.","category":"page"},{"location":"integrators/rk4/","page":"4th Order Runge-Kutta","title":"4th Order Runge-Kutta","text":"using SimpleSim\n\n# my_model = ...\n\nout = simulate(my_model, T = T_end, integrator = RK4)","category":"page"},{"location":"integrators/rk4/#Mathematical-Background","page":"4th Order Runge-Kutta","title":"Mathematical Background","text":"","category":"section"},{"location":"integrators/rk4/","page":"4th Order Runge-Kutta","title":"4th Order Runge-Kutta","text":"As the name suggests, this method is a four-step algorithm.","category":"page"},{"location":"integrators/rk4/","page":"4th Order Runge-Kutta","title":"4th Order Runge-Kutta","text":"First, the derivative function f is evaluated at four different points.","category":"page"},{"location":"integrators/rk4/","page":"4th Order Runge-Kutta","title":"4th Order Runge-Kutta","text":"k_1 = f(x u(t) p t)","category":"page"},{"location":"integrators/rk4/","page":"4th Order Runge-Kutta","title":"4th Order Runge-Kutta","text":"k_2 = f(x + fracDelta t2 k_1 u(t + fracDelta t2) p t + fracDelta t2)","category":"page"},{"location":"integrators/rk4/","page":"4th Order Runge-Kutta","title":"4th Order Runge-Kutta","text":"k_3 = f(x + fracDelta t2 k_2 u(t + fracDelta t2) p t + fracDelta t2)","category":"page"},{"location":"integrators/rk4/","page":"4th Order Runge-Kutta","title":"4th Order Runge-Kutta","text":"k_4 = f(x + Delta tcdot k_3 u(t + Delta t) p t + Delta t)","category":"page"},{"location":"integrators/rk4/","page":"4th Order Runge-Kutta","title":"4th Order Runge-Kutta","text":"The RK4 estimate of the state at time t + Delta t is then given by the weighted average.","category":"page"},{"location":"integrators/rk4/","page":"4th Order Runge-Kutta","title":"4th Order Runge-Kutta","text":"x^+ = x + fracDelta t6 (k_1 + 2 k_2 + 2 k_3 + k_4)","category":"page"},{"location":"integrators/rk4/#Performance","page":"4th Order Runge-Kutta","title":"Performance","text":"","category":"section"},{"location":"integrators/rk4/","page":"4th Order Runge-Kutta","title":"4th Order Runge-Kutta","text":"The fourth-order Runge-Kutta method requires four calls of the dynamics function and is therefore the slowest out of all fixed step-size methods provided by SimpleSim.jl.","category":"page"},{"location":"integrators/rk4/","page":"4th Order Runge-Kutta","title":"4th Order Runge-Kutta","text":"In most cases, however, the evaluation of f is fast enought so that RK4 can be used as the standard integration method.","category":"page"},{"location":"integrators/rk4/","page":"4th Order Runge-Kutta","title":"4th Order Runge-Kutta","text":"The advantages in terms of precision compared to first and second order methods are imense and generally RK4 is sufficiently exact.","category":"page"},{"location":"integrators/rk4/","page":"4th Order Runge-Kutta","title":"4th Order Runge-Kutta","text":"In rare cases, however, an adaptive step-size variation of RK4 should be used. See the chapter about Runge-Kutta-Fehlberg for more information.","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"SimpleSim.jl is a minimalist Julia framework for modular dynamical system simulation.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For installation, run import Pkg; Pkg.add(\"SimpleSim.jl\") from within your Julia environment.","category":"page"},{"location":"#Philosophy","page":"Introduction","title":"Philosophy","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This software project aims at removing a lot of the overhead that a lot of the existing simulation frameworks out there have. SimpleSim.jl does not export any types. The interface almost solely consists of the function simulate and a agreed-upon model structure. The light interface results in most design decisions left up to the user.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"At the same time SimpleSim.jl does not compromise on functionality and offers a feature-rich simulation framework.","category":"page"},{"location":"#Short-overview","page":"Introduction","title":"Short overview","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The main point of interaction with the SimpleSim.jl framework is the simulate function. As a first argument it expects to be passed some object that provides hooks with certain names for various functionalities.","category":"page"},{"location":"#Continuous-Time-Systems","page":"Introduction","title":"Continuous-Time Systems","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"A simple example of a dynamical system model accepted by SimpleSim.jl would be","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"my_model = (\n    p = nothing,\n    fc = dynamics_function,\n    gc = measurement_function,\n)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"where we pass nothing as the parameters of the model (i.e. we don't need any parameters right now) and two functions dynamics_function and measurement_function that we defined elsewhere.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"These two functions follow the typical dynamical systems approach for continuous-time systems","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"dotx(t) = f(x(t) u(t) p t)\ny(t) = g(x(t) u(t) p t)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"or in Julia","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"dynamics_function = (x, u, p t) -> ...\nmeasurement_function = (x, u, p t) -> ...","category":"page"},{"location":"#Discrete-Time-Systems","page":"Introduction","title":"Discrete-Time Systems","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Similarly for a discrete-time system we write","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"next_state_function = (x, u, p, t) -> ...\ndt_measurement_function = (x, u, p, t) -> ...\n\nmy_dt_model = (\n    p = nothing,\n    fd = next_state_function,\n    gd = dt_measurement_function,\n    Δt = 1 // 10,\n)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"modeling the system","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"x_k+1 = f(x_k u_k p t)\ny_k = g(x_k u_k p t)","category":"page"},{"location":"#Running-Simulations","page":"Introduction","title":"Running Simulations","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Simulating a model is done by calling the simulate function","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"out = simulate(my_model, T = 10 // 1)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"add the keyword argument xc0 = or xd0 = to set the initial state of your continuous-time or discrete-time model, respectively.","category":"page"},{"location":"#Modularity","page":"Introduction","title":"Modularity","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"SimpleSim.jl takes a hierarchical approach to more complex, modular systems. That means any model can have any number of submodels. To define submodels, a Vector, Tuple or NamedTuple of models is passed to the models keywords on creation of the model.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"submodel_1 = (\n    p = nothing,\n    fc = ...,\n    gc = ...,\n)\n\nsubmodel_2 = ...\n\nparent_model = (\n    p = nothing,\n    fc = fc_parent,\n    gc = gc_parent,\n    models = (\n        model_1 = submodel_1,\n        model_2 = submodel_2,\n    )\n)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Now, parent_model has two submodels. Note, that submodels are not updated automatically. They have to be called by their parent model. Only the top-level model passed to simulate is actively updated by SimpleSim.jl.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For calling a submodel, use the @call! macro from within a gc function and add the input you want to give the submodel.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"function gc_parent(x, u, p, t; models)\n    u_1 = ...\n    y_submodel_1 = @call! models.model_1 u_1\n\n    u_2 = ...\n    y_submodel_2 = @call! models.model_2 u_2\n\n    return ...\nend","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Calls can only be made from within a gc function. Not from within an fc function. To obtain the current output of a submodel without updating it, use the @out macro.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"function fc_parent(x, u, p, t; models)\n    y_1 = @out models.model_1\n    # ...\nend","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Discrete-time systems work in the same way. However, SimpleSim.jl makes sure that discrete-time models are only updated according to their update frequency.","category":"page"},{"location":"#Citing","page":"Introduction","title":"Citing","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"If you used SimpleSim.jl in research and you are preparing a publication, please use the following BiBTeX entry:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@software{SimpleSim,\n    author = {H{\\\"u}hnerbein, Jannes},\n    title = {{S}imple{S}im.jl: {A} minimalist {J}ulia package for modular dynamical systems simulation},\n    url = {https://github.com/janneshb/SimpleSim.jl},\n    version = {0.1.4},\n    year = {2024},\n    month = {04},\n}","category":"page"},{"location":"manual/run_sims/#Running-Simulations","page":"Running Simulations","title":"Running Simulations","text":"","category":"section"},{"location":"manual/run_sims/","page":"Running Simulations","title":"Running Simulations","text":"out = simulate(my_model, T = T_end)","category":"page"},{"location":"manual/run_sims/","page":"Running Simulations","title":"Running Simulations","text":"Mandatory Keyword Arguments:","category":"page"},{"location":"manual/run_sims/","page":"Running Simulations","title":"Running Simulations","text":"T total time of the simulation","category":"page"},{"location":"manual/run_sims/","page":"Running Simulations","title":"Running Simulations","text":"Optional Keyword Arguments:","category":"page"},{"location":"manual/run_sims/","page":"Running Simulations","title":"Running Simulations","text":"t0 initial time, defaults to 0//1\nxd0 initial state, defaults to nothing. Overwrites initial state given in model.\nud input function  (t) -> some_input, if none is given, the input will be nothing for all times.","category":"page"},{"location":"manual/run_sims/","page":"Running Simulations","title":"Running Simulations","text":"Supported Keywords with no Effect for DT Simulations:","category":"page"},{"location":"manual/run_sims/","page":"Running Simulations","title":"Running Simulations","text":"uc input only used for continuous-time models\nxc0 initial state only used for continuous-time models\nintegator no integrator is used for discrete-time simulations\nΔt_max only relevant for integrators and therefore irrelevant for discrete-time models","category":"page"},{"location":"manual/run_sims/#TODO:-add-some-more-info","page":"Running Simulations","title":"TODO: add some more info","text":"","category":"section"}]
}
